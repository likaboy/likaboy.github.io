<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>who care @Transactional, how @transactional is use</title>
    <link href="/2025/03/03/who-care-Transactional-how-transactional-is-use/"/>
    <url>/2025/03/03/who-care-Transactional-how-transactional-is-use/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是-Transactional-？"><a href="#什么是-Transactional-？" class="headerlink" title="什么是 @Transactional ？"></a>什么是 @Transactional ？</h2><h3 id="第一个前提是什么是事务？"><a href="#第一个前提是什么是事务？" class="headerlink" title="第一个前提是什么是事务？"></a>第一个前提是什么是事务？</h3><p>是由N步数据库操作序列组成的逻辑执行单元，这系列操作要么全执行，要么全放弃执行。</p><h3 id="为什么会有要么，要么的结果？"><a href="#为什么会有要么，要么的结果？" class="headerlink" title="为什么会有要么，要么的结果？"></a>为什么会有要么，要么的结果？</h3><p>这是由事务的特性决定<br>ACID</p><ul><li>A：Atomicity : 原子性<ul><li>数据的变化只会有一种结果。</li></ul></li><li>C：Consistency : 一致性<ul><li>当数据发生变化时，需全部由一种状态，转变为另一种状态。</li></ul></li><li>I: Isolation : 隔离性<ul><li>事务与事务之间保持隔离，每个事务内部的操作对其他事务不可见，也不会造成影响。</li></ul></li><li>D：Durability : 持久性<ul><li>事务一旦成功提交，所提交的结果数据将被永久的储存。直到下一次新的事务对其进行操作</li></ul></li></ul><h3 id="Transactional"><a href="#Transactional" class="headerlink" title="@Transactional"></a>@Transactional</h3><p>@Transactional 是 Spring 框架提供的声明式事务管理方式，理论上，如果采用了 @Transactional ，其范围内的代码流程对应事务管理遵守ACID。</p><p>这里是源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Copyright 2002-2022 the original author or authors.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span><br><span class="hljs-comment"> * you may not use this file except in compliance with the License.</span><br><span class="hljs-comment"> * You may obtain a copy of the License at</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *      https://www.apache.org/licenses/LICENSE-2.0</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Unless required by applicable law or agreed to in writing, software</span><br><span class="hljs-comment"> * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span><br><span class="hljs-comment"> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span><br><span class="hljs-comment"> * See the License for the specific language governing permissions and</span><br><span class="hljs-comment"> * limitations under the License.</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">package</span> org.springframework.transaction.annotation;<br><br><span class="hljs-keyword">import</span> java.lang.annotation.Documented;<br><span class="hljs-keyword">import</span> java.lang.annotation.ElementType;<br><span class="hljs-keyword">import</span> java.lang.annotation.Inherited;<br><span class="hljs-keyword">import</span> java.lang.annotation.Retention;<br><span class="hljs-keyword">import</span> java.lang.annotation.RetentionPolicy;<br><span class="hljs-keyword">import</span> java.lang.annotation.Target;<br><br><span class="hljs-keyword">import</span> org.springframework.core.annotation.AliasFor;<br><span class="hljs-keyword">import</span> org.springframework.transaction.TransactionDefinition;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Describes a transaction attribute on an individual method or on a class.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * &lt;p&gt;When this annotation is declared at the class level, it applies as a default</span><br><span class="hljs-comment"> * to all methods of the declaring class and its subclasses. Note that it does not</span><br><span class="hljs-comment"> * apply to ancestor classes up the class hierarchy; inherited methods need to be</span><br><span class="hljs-comment"> * locally redeclared in order to participate in a subclass-level annotation. For</span><br><span class="hljs-comment"> * details on method visibility constraints, consult the</span><br><span class="hljs-comment"> * &lt;a href=&quot;https://docs.spring.io/spring-framework/docs/current/reference/html/data-access.html#transaction&quot;&gt;Transaction Management&lt;/a&gt;</span><br><span class="hljs-comment"> * section of the reference manual.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * &lt;p&gt;This annotation is generally directly comparable to Spring&#x27;s</span><br><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@link</span> org.springframework.transaction.interceptor.RuleBasedTransactionAttribute&#125;</span><br><span class="hljs-comment"> * class, and in fact &#123;<span class="hljs-doctag">@link</span> AnnotationTransactionAttributeSource&#125; will directly</span><br><span class="hljs-comment"> * convert this annotation&#x27;s attributes to properties in &#123;<span class="hljs-doctag">@code</span> RuleBasedTransactionAttribute&#125;,</span><br><span class="hljs-comment"> * so that Spring&#x27;s transaction support code does not have to know about annotations.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * &lt;h3&gt;Attribute Semantics&lt;/h3&gt;</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * &lt;p&gt;If no custom rollback rules are configured in this annotation, the transaction</span><br><span class="hljs-comment"> * will roll back on &#123;<span class="hljs-doctag">@link</span> RuntimeException&#125; and &#123;<span class="hljs-doctag">@link</span> Error&#125; but not on checked</span><br><span class="hljs-comment"> * exceptions.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * &lt;p&gt;Rollback rules determine if a transaction should be rolled back when a given</span><br><span class="hljs-comment"> * exception is thrown, and the rules are based on patterns. A pattern can be a</span><br><span class="hljs-comment"> * fully qualified class name or a substring of a fully qualified class name for</span><br><span class="hljs-comment"> * an exception type (which must be a subclass of &#123;<span class="hljs-doctag">@code</span> Throwable&#125;), with no</span><br><span class="hljs-comment"> * wildcard support at present. For example, a value of</span><br><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@code</span> &quot;javax.servlet.ServletException&quot;&#125; or &#123;<span class="hljs-doctag">@code</span> &quot;ServletException&quot;&#125; will</span><br><span class="hljs-comment"> * match &#123;<span class="hljs-doctag">@code</span> javax.servlet.ServletException&#125; and its subclasses.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * &lt;p&gt;Rollback rules may be configured via &#123;<span class="hljs-doctag">@link</span> #rollbackFor&#125;/&#123;<span class="hljs-doctag">@link</span> #noRollbackFor&#125;</span><br><span class="hljs-comment"> * and &#123;<span class="hljs-doctag">@link</span> #rollbackForClassName&#125;/&#123;<span class="hljs-doctag">@link</span> #noRollbackForClassName&#125;, which allow</span><br><span class="hljs-comment"> * patterns to be specified as &#123;<span class="hljs-doctag">@link</span> Class&#125; references or &#123;<span class="hljs-doctag">@linkplain</span> String</span><br><span class="hljs-comment"> * strings&#125;, respectively. When an exception type is specified as a class reference</span><br><span class="hljs-comment"> * its fully qualified name will be used as the pattern. Consequently,</span><br><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@code</span> <span class="hljs-doctag">@Transactional</span>(rollbackFor = example.CustomException.class)&#125; is equivalent</span><br><span class="hljs-comment"> * to &#123;<span class="hljs-doctag">@code</span> <span class="hljs-doctag">@Transactional</span>(rollbackForClassName = &quot;example.CustomException&quot;)&#125;.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * &lt;p&gt;&lt;strong&gt;WARNING:&lt;/strong&gt; You must carefully consider how specific the pattern</span><br><span class="hljs-comment"> * is and whether to include package information (which isn&#x27;t mandatory). For example,</span><br><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@code</span> &quot;Exception&quot;&#125; will match nearly anything and will probably hide other</span><br><span class="hljs-comment"> * rules. &#123;<span class="hljs-doctag">@code</span> &quot;java.lang.Exception&quot;&#125; would be correct if &#123;<span class="hljs-doctag">@code</span> &quot;Exception&quot;&#125;</span><br><span class="hljs-comment"> * were meant to define a rule for all checked exceptions. With more unique</span><br><span class="hljs-comment"> * exception names such as &#123;<span class="hljs-doctag">@code</span> &quot;BaseBusinessException&quot;&#125; there is likely no</span><br><span class="hljs-comment"> * need to use the fully qualified class name for the exception pattern. Furthermore,</span><br><span class="hljs-comment"> * rollback rules may result in unintentional matches for similarly named exceptions</span><br><span class="hljs-comment"> * and nested classes. This is due to the fact that a thrown exception is considered</span><br><span class="hljs-comment"> * to be a match for a given rollback rule if the name of thrown exception contains</span><br><span class="hljs-comment"> * the exception pattern configured for the rollback rule. For example, given a</span><br><span class="hljs-comment"> * rule configured to match on &#123;<span class="hljs-doctag">@code</span> com.example.CustomException&#125;, that rule</span><br><span class="hljs-comment"> * would match against an exception named</span><br><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@code</span> com.example.CustomExceptionV2&#125; (an exception in the same package as</span><br><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@code</span> CustomException&#125; but with an additional suffix) or an exception named</span><br><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@code</span> com.example.CustomException$AnotherException&#125;</span><br><span class="hljs-comment"> * (an exception declared as a nested class in &#123;<span class="hljs-doctag">@code</span> CustomException&#125;).</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * &lt;p&gt;For specific information about the semantics of other attributes in this</span><br><span class="hljs-comment"> * annotation, consult the &#123;<span class="hljs-doctag">@link</span> org.springframework.transaction.TransactionDefinition&#125;</span><br><span class="hljs-comment"> * and &#123;<span class="hljs-doctag">@link</span> org.springframework.transaction.interceptor.TransactionAttribute&#125; javadocs.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * &lt;h3&gt;Transaction Management&lt;/h3&gt;</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * &lt;p&gt;This annotation commonly works with thread-bound transactions managed by a</span><br><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@link</span> org.springframework.transaction.PlatformTransactionManager&#125;, exposing a</span><br><span class="hljs-comment"> * transaction to all data access operations within the current execution thread.</span><br><span class="hljs-comment"> * &lt;b&gt;Note: This does NOT propagate to newly started threads within the method.&lt;/b&gt;</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * &lt;p&gt;Alternatively, this annotation may demarcate a reactive transaction managed</span><br><span class="hljs-comment"> * by a &#123;<span class="hljs-doctag">@link</span> org.springframework.transaction.ReactiveTransactionManager&#125; which</span><br><span class="hljs-comment"> * uses the Reactor context instead of thread-local variables. As a consequence,</span><br><span class="hljs-comment"> * all participating data access operations need to execute within the same</span><br><span class="hljs-comment"> * Reactor context in the same reactive pipeline.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Colin Sampaleanu</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Juergen Hoeller</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Sam Brannen</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Mark Paluch</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> 1.2</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> org.springframework.transaction.interceptor.TransactionAttribute</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> org.springframework.transaction.interceptor.DefaultTransactionAttribute</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> org.springframework.transaction.interceptor.RuleBasedTransactionAttribute</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Inherited</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Transactional &#123;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Alias for &#123;<span class="hljs-doctag">@link</span> #transactionManager&#125;.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> #transactionManager</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@AliasFor(&quot;transactionManager&quot;)</span><br>String <span class="hljs-title function_">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * A &lt;em&gt;qualifier&lt;/em&gt; value for the specified transaction.</span><br><span class="hljs-comment"> * &lt;p&gt;May be used to determine the target transaction manager, matching the</span><br><span class="hljs-comment"> * qualifier value (or the bean name) of a specific</span><br><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@link</span> org.springframework.transaction.TransactionManager TransactionManager&#125;</span><br><span class="hljs-comment"> * bean definition.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> 4.2</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> #value</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> org.springframework.transaction.PlatformTransactionManager</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> org.springframework.transaction.ReactiveTransactionManager</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@AliasFor(&quot;value&quot;)</span><br>String <span class="hljs-title function_">transactionManager</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Defines zero (0) or more transaction labels.</span><br><span class="hljs-comment"> * &lt;p&gt;Labels may be used to describe a transaction, and they can be evaluated</span><br><span class="hljs-comment"> * by individual transaction managers. Labels may serve a solely descriptive</span><br><span class="hljs-comment"> * purpose or map to pre-defined transaction manager-specific options.</span><br><span class="hljs-comment"> * &lt;p&gt;See the documentation of the actual transaction manager implementation</span><br><span class="hljs-comment"> * for details on how it evaluates transaction labels.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> 5.3</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> org.springframework.transaction.interceptor.DefaultTransactionAttribute#getLabels()</span><br><span class="hljs-comment"> */</span><br>String[] label() <span class="hljs-keyword">default</span> &#123;&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * The transaction propagation type.</span><br><span class="hljs-comment"> * &lt;p&gt;Defaults to &#123;<span class="hljs-doctag">@link</span> Propagation#REQUIRED&#125;.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> org.springframework.transaction.interceptor.TransactionAttribute#getPropagationBehavior()</span><br><span class="hljs-comment"> */</span><br>Propagation <span class="hljs-title function_">propagation</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> Propagation.REQUIRED;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * The transaction isolation level.</span><br><span class="hljs-comment"> * &lt;p&gt;Defaults to &#123;<span class="hljs-doctag">@link</span> Isolation#DEFAULT&#125;.</span><br><span class="hljs-comment"> * &lt;p&gt;Exclusively designed for use with &#123;<span class="hljs-doctag">@link</span> Propagation#REQUIRED&#125; or</span><br><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@link</span> Propagation#REQUIRES_NEW&#125; since it only applies to newly started</span><br><span class="hljs-comment"> * transactions. Consider switching the &quot;validateExistingTransactions&quot; flag to</span><br><span class="hljs-comment"> * &quot;true&quot; on your transaction manager if you&#x27;d like isolation level declarations</span><br><span class="hljs-comment"> * to get rejected when participating in an existing transaction with a different</span><br><span class="hljs-comment"> * isolation level.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> org.springframework.transaction.interceptor.TransactionAttribute#getIsolationLevel()</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> org.springframework.transaction.support.AbstractPlatformTransactionManager#setValidateExistingTransaction</span><br><span class="hljs-comment"> */</span><br>Isolation <span class="hljs-title function_">isolation</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> Isolation.DEFAULT;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * The timeout for this transaction (in seconds).</span><br><span class="hljs-comment"> * &lt;p&gt;Defaults to the default timeout of the underlying transaction system.</span><br><span class="hljs-comment"> * &lt;p&gt;Exclusively designed for use with &#123;<span class="hljs-doctag">@link</span> Propagation#REQUIRED&#125; or</span><br><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@link</span> Propagation#REQUIRES_NEW&#125; since it only applies to newly started</span><br><span class="hljs-comment"> * transactions.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> the timeout in seconds</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> org.springframework.transaction.interceptor.TransactionAttribute#getTimeout()</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">timeout</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> TransactionDefinition.TIMEOUT_DEFAULT;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * The timeout for this transaction (in seconds).</span><br><span class="hljs-comment"> * &lt;p&gt;Defaults to the default timeout of the underlying transaction system.</span><br><span class="hljs-comment"> * &lt;p&gt;Exclusively designed for use with &#123;<span class="hljs-doctag">@link</span> Propagation#REQUIRED&#125; or</span><br><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@link</span> Propagation#REQUIRES_NEW&#125; since it only applies to newly started</span><br><span class="hljs-comment"> * transactions.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> the timeout in seconds as a String value, e.g. a placeholder</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> 5.3</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> org.springframework.transaction.interceptor.TransactionAttribute#getTimeout()</span><br><span class="hljs-comment"> */</span><br>String <span class="hljs-title function_">timeoutString</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * A boolean flag that can be set to &#123;<span class="hljs-doctag">@code</span> true&#125; if the transaction is</span><br><span class="hljs-comment"> * effectively read-only, allowing for corresponding optimizations at runtime.</span><br><span class="hljs-comment"> * &lt;p&gt;Defaults to &#123;<span class="hljs-doctag">@code</span> false&#125;.</span><br><span class="hljs-comment"> * &lt;p&gt;This just serves as a hint for the actual transaction subsystem;</span><br><span class="hljs-comment"> * it will &lt;i&gt;not necessarily&lt;/i&gt; cause failure of write access attempts.</span><br><span class="hljs-comment"> * A transaction manager which cannot interpret the read-only hint will</span><br><span class="hljs-comment"> * &lt;i&gt;not&lt;/i&gt; throw an exception when asked for a read-only transaction</span><br><span class="hljs-comment"> * but rather silently ignore the hint.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> org.springframework.transaction.interceptor.TransactionAttribute#isReadOnly()</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> org.springframework.transaction.support.TransactionSynchronizationManager#isCurrentTransactionReadOnly()</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">readOnly</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-literal">false</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Defines zero (0) or more exception &#123;<span class="hljs-doctag">@linkplain</span> Class classes&#125;, which must be</span><br><span class="hljs-comment"> * subclasses of &#123;<span class="hljs-doctag">@link</span> Throwable&#125;, indicating which exception types must cause</span><br><span class="hljs-comment"> * a transaction rollback.</span><br><span class="hljs-comment"> * &lt;p&gt;By default, a transaction will be rolled back on &#123;<span class="hljs-doctag">@link</span> RuntimeException&#125;</span><br><span class="hljs-comment"> * and &#123;<span class="hljs-doctag">@link</span> Error&#125; but not on checked exceptions (business exceptions). See</span><br><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@link</span> org.springframework.transaction.interceptor.DefaultTransactionAttribute#rollbackOn(Throwable)&#125;</span><br><span class="hljs-comment"> * for a detailed explanation.</span><br><span class="hljs-comment"> * &lt;p&gt;This is the preferred way to construct a rollback rule (in contrast to</span><br><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@link</span> #rollbackForClassName&#125;), matching the exception type, its subclasses,</span><br><span class="hljs-comment"> * and its nested classes. See the &#123;<span class="hljs-doctag">@linkplain</span> Transactional class-level javadocs&#125;</span><br><span class="hljs-comment"> * for further details on rollback rule semantics and warnings regarding possible</span><br><span class="hljs-comment"> * unintentional matches.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> #rollbackForClassName</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> org.springframework.transaction.interceptor.RollbackRuleAttribute#RollbackRuleAttribute(Class)</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> org.springframework.transaction.interceptor.DefaultTransactionAttribute#rollbackOn(Throwable)</span><br><span class="hljs-comment"> */</span><br>Class&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Throwable</span>&gt;[] rollbackFor() <span class="hljs-keyword">default</span> &#123;&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Defines zero (0) or more exception name patterns (for exceptions which must be a</span><br><span class="hljs-comment"> * subclass of &#123;<span class="hljs-doctag">@link</span> Throwable&#125;), indicating which exception types must cause</span><br><span class="hljs-comment"> * a transaction rollback.</span><br><span class="hljs-comment"> * &lt;p&gt;See the &#123;<span class="hljs-doctag">@linkplain</span> Transactional class-level javadocs&#125; for further details</span><br><span class="hljs-comment"> * on rollback rule semantics, patterns, and warnings regarding possible</span><br><span class="hljs-comment"> * unintentional matches.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> #rollbackFor</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> org.springframework.transaction.interceptor.RollbackRuleAttribute#RollbackRuleAttribute(String)</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> org.springframework.transaction.interceptor.DefaultTransactionAttribute#rollbackOn(Throwable)</span><br><span class="hljs-comment"> */</span><br>String[] rollbackForClassName() <span class="hljs-keyword">default</span> &#123;&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Defines zero (0) or more exception &#123;<span class="hljs-doctag">@link</span> Class Classes&#125;, which must be</span><br><span class="hljs-comment"> * subclasses of &#123;<span class="hljs-doctag">@link</span> Throwable&#125;, indicating which exception types must</span><br><span class="hljs-comment"> * &lt;b&gt;not&lt;/b&gt; cause a transaction rollback.</span><br><span class="hljs-comment"> * &lt;p&gt;This is the preferred way to construct a rollback rule (in contrast to</span><br><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@link</span> #noRollbackForClassName&#125;), matching the exception type, its subclasses,</span><br><span class="hljs-comment"> * and its nested classes. See the &#123;<span class="hljs-doctag">@linkplain</span> Transactional class-level javadocs&#125;</span><br><span class="hljs-comment"> * for further details on rollback rule semantics and warnings regarding possible</span><br><span class="hljs-comment"> * unintentional matches.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> #noRollbackForClassName</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> org.springframework.transaction.interceptor.NoRollbackRuleAttribute#NoRollbackRuleAttribute(Class)</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> org.springframework.transaction.interceptor.DefaultTransactionAttribute#rollbackOn(Throwable)</span><br><span class="hljs-comment"> */</span><br>Class&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Throwable</span>&gt;[] noRollbackFor() <span class="hljs-keyword">default</span> &#123;&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Defines zero (0) or more exception name patterns (for exceptions which must be a</span><br><span class="hljs-comment"> * subclass of &#123;<span class="hljs-doctag">@link</span> Throwable&#125;) indicating which exception types must &lt;b&gt;not&lt;/b&gt;</span><br><span class="hljs-comment"> * cause a transaction rollback.</span><br><span class="hljs-comment"> * &lt;p&gt;See the &#123;<span class="hljs-doctag">@linkplain</span> Transactional class-level javadocs&#125; for further details</span><br><span class="hljs-comment"> * on rollback rule semantics, patterns, and warnings regarding possible</span><br><span class="hljs-comment"> * unintentional matches.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> #noRollbackFor</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> org.springframework.transaction.interceptor.NoRollbackRuleAttribute#NoRollbackRuleAttribute(String)</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> org.springframework.transaction.interceptor.DefaultTransactionAttribute#rollbackOn(Throwable)</span><br><span class="hljs-comment"> */</span><br>String[] noRollbackForClassName() <span class="hljs-keyword">default</span> &#123;&#125;;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><p>这里可以看到  Propagation（传播属性） 默认的是 REQUIRED，也就是多个事务互相调用时，事务如何在这些方法间传播。</p><p>这里可以看下 Propagation 这个枚举类的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.springframework.transaction.annotation;<br><br><span class="hljs-keyword">import</span> org.springframework.transaction.TransactionDefinition;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Enumeration that represents transaction propagation behaviors for use</span><br><span class="hljs-comment"> * with the &#123;<span class="hljs-doctag">@link</span> Transactional&#125; annotation, corresponding to the</span><br><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@link</span> TransactionDefinition&#125; interface.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Colin Sampaleanu</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Juergen Hoeller</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> 1.2</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Propagation</span> &#123;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Support a current transaction, create a new one if none exists.</span><br><span class="hljs-comment"> * Analogous to EJB transaction attribute of the same name.</span><br><span class="hljs-comment"> * &lt;p&gt;This is the default setting of a transaction annotation.</span><br><span class="hljs-comment"> */</span><br>REQUIRED(TransactionDefinition.PROPAGATION_REQUIRED),<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Support a current transaction, execute non-transactionally if none exists.</span><br><span class="hljs-comment"> * Analogous to EJB transaction attribute of the same name.</span><br><span class="hljs-comment"> * &lt;p&gt;Note: For transaction managers with transaction synchronization,</span><br><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@code</span> SUPPORTS&#125; is slightly different from no transaction at all,</span><br><span class="hljs-comment"> * as it defines a transaction scope that synchronization will apply for.</span><br><span class="hljs-comment"> * As a consequence, the same resources (JDBC Connection, Hibernate Session, etc)</span><br><span class="hljs-comment"> * will be shared for the entire specified scope. Note that this depends on</span><br><span class="hljs-comment"> * the actual synchronization configuration of the transaction manager.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> org.springframework.transaction.support.AbstractPlatformTransactionManager#setTransactionSynchronization</span><br><span class="hljs-comment"> */</span><br>SUPPORTS(TransactionDefinition.PROPAGATION_SUPPORTS),<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Support a current transaction, throw an exception if none exists.</span><br><span class="hljs-comment"> * Analogous to EJB transaction attribute of the same name.</span><br><span class="hljs-comment"> */</span><br>MANDATORY(TransactionDefinition.PROPAGATION_MANDATORY),<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Create a new transaction, and suspend the current transaction if one exists.</span><br><span class="hljs-comment"> * Analogous to the EJB transaction attribute of the same name.</span><br><span class="hljs-comment"> * &lt;p&gt;&lt;b&gt;<span class="hljs-doctag">NOTE:</span>&lt;/b&gt; Actual transaction suspension will not work out-of-the-box</span><br><span class="hljs-comment"> * on all transaction managers. This in particular applies to</span><br><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@link</span> org.springframework.transaction.jta.JtaTransactionManager&#125;,</span><br><span class="hljs-comment"> * which requires the &#123;<span class="hljs-doctag">@code</span> javax.transaction.TransactionManager&#125; to be</span><br><span class="hljs-comment"> * made available to it (which is server-specific in standard Java EE).</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> org.springframework.transaction.jta.JtaTransactionManager#setTransactionManager</span><br><span class="hljs-comment"> */</span><br>REQUIRES_NEW(TransactionDefinition.PROPAGATION_REQUIRES_NEW),<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Execute non-transactionally, suspend the current transaction if one exists.</span><br><span class="hljs-comment"> * Analogous to EJB transaction attribute of the same name.</span><br><span class="hljs-comment"> * &lt;p&gt;&lt;b&gt;<span class="hljs-doctag">NOTE:</span>&lt;/b&gt; Actual transaction suspension will not work out-of-the-box</span><br><span class="hljs-comment"> * on all transaction managers. This in particular applies to</span><br><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@link</span> org.springframework.transaction.jta.JtaTransactionManager&#125;,</span><br><span class="hljs-comment"> * which requires the &#123;<span class="hljs-doctag">@code</span> javax.transaction.TransactionManager&#125; to be</span><br><span class="hljs-comment"> * made available to it (which is server-specific in standard Java EE).</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> org.springframework.transaction.jta.JtaTransactionManager#setTransactionManager</span><br><span class="hljs-comment"> */</span><br>NOT_SUPPORTED(TransactionDefinition.PROPAGATION_NOT_SUPPORTED),<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Execute non-transactionally, throw an exception if a transaction exists.</span><br><span class="hljs-comment"> * Analogous to EJB transaction attribute of the same name.</span><br><span class="hljs-comment"> */</span><br>NEVER(TransactionDefinition.PROPAGATION_NEVER),<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Execute within a nested transaction if a current transaction exists,</span><br><span class="hljs-comment"> * behave like &#123;<span class="hljs-doctag">@code</span> REQUIRED&#125; otherwise. There is no analogous feature in EJB.</span><br><span class="hljs-comment"> * &lt;p&gt;Note: Actual creation of a nested transaction will only work on specific</span><br><span class="hljs-comment"> * transaction managers. Out of the box, this only applies to the JDBC</span><br><span class="hljs-comment"> * DataSourceTransactionManager. Some JTA providers might support nested</span><br><span class="hljs-comment"> * transactions as well.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> org.springframework.jdbc.datasource.DataSourceTransactionManager</span><br><span class="hljs-comment"> */</span><br>NESTED(TransactionDefinition.PROPAGATION_NESTED);<br><br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> value;<br><br><br>Propagation(<span class="hljs-type">int</span> value) &#123;<br><span class="hljs-built_in">this</span>.value = value;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">value</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.value;<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>对源码的解释：</p><ul><li><p><strong>PROPAGATION_REQUIRED</strong></p><ul><li>支持当前事务，如果当前存在事务，则加入该事务。</li><li>如果当前没有事务，则新建一个事务。</li><li><strong>场景：适用于大多数需要事务支持的操作。例如，当你有一个方法需要确保所有数据库操作要么全部成功，要么全部失败时，可以使用这个属性。</strong></li></ul></li><li><p><strong>PROPAGATION_SUPPORTS</strong></p><ul><li>支持当前事务，如果当前存在事务，则加入该事务。</li><li>如果当前没有事务，则以非事务方式执行。</li><li>比如两个实现类串成一个责任链，调用这个责任链的类开启了默认事务，如果外围类发生异常，整个责任链的调用也会回滚。外围类一并回滚，在这里内外属于同一个事务。</li><li><strong>场景：适用于不需要事务支持但希望在事务中运行的操作。例如，日志记录功能，它可以在事务中运行以确保日志与实际业务操作保持一致，但如果事务不存在，也可以正常执行。一般来说，如果外围类调用失败，内部的日志记录将会停止记录此次操作，但不会影响外围类的其他不在事务内的上下文日志记录</strong></li></ul></li><li><p><strong>PROPAGATION_MANDATORY</strong></p><ul><li>支持当前事务，如果当前存在事务，则加入该事务。</li><li>如果当前没有事务，则抛出异常。</li><li><strong>场景：适用于必须在一个事务中执行的操作。例如，某些敏感操作，如果事务不存在可能无法保证数据一致性，因此抛出异常是合理的选择。这也是属于责任链的安全机制，如果一个没有事务配置的类调用了需要事务的类，则会触发责任链内的异常抛出</strong></li></ul></li><li><p><strong>PROPAGATION_REQUIRES_NEW</strong></p><ul><li>新建事务，如果当前存在事务，则将当前事务挂起。</li><li>如果当前没有事务，则新建一个事务。</li><li><strong>场景：适用于需要独立事务的场景，例如，当一个方法需要保证其操作绝对独立于其他操作时，可以使用此属性。例如，处理支付操作，需要确保支付操作在一个独立的事务中完成，不受其他操作的影响。比如各大银行都会有的骚操作：支付流程必须在一个事务中执行！</strong></li></ul></li><li><p><strong>PROPAGATION_NOT_SUPPORTED</strong></p><ul><li>以非事务方式执行，如果当前存在事务，则将当前事务挂起。</li><li>如果当前没有事务，则以非事务方式执行。</li><li>是指如果存在事务则将这个事务挂起，并使用新的数据库连接。新的数据库连接不使用事务</li><li><strong>场景：适用于不需要事务支持的操作，但希望在事务存在时暂停它。例如，某些不需要持久化的查询操作，可以在事务中暂停，以提高性能。还是记录日志，日志记录可以多一条和少一条，但不会影响实际业务操作。上级方法抛出异常不会影响日志记录，同样，日志记录抛出异常不会影响上级方法</strong></li></ul></li><li><p><strong>PROPAGATION_NEVER</strong></p><ul><li>如果上级方法有事务，则抛出异常。</li><li>如果调用 Propagation.NEVER 的方法时，当前线程已经有活跃的事务，Spring 会抛出异常（比如 IllegalTransactionStateException）。因此，使用时需要确保调用上下文符合预期。</li><li>它与 Propagation.NOT_SUPPORTED 类似，但区别在于：NOT_SUPPORTED 会暂停当前事务并以非事务方式运行，而 NEVER 直接拒绝任何事务上下文。</li><li><strong>场景 适用于明确要求非事务环境的场景(日志记录、监控操作或某些只读操作)，通常是为了性能优化、逻辑独立性或特定业务需求。(更主要的是避免事务带来的性能开销,以及业务逻辑要求某个方法必须独立于调用方的事务上下文（比如某些外部系统调用或非事务性操作）)如果你需要的是“暂停事务但仍运行”，可以考虑 Propagation.NOT_SUPPORTED；而如果完全拒绝事务，NEVER 是更严格的选择。</strong></li></ul></li><li><p><strong>PROPAGATION_NESTED</strong></p><ul><li>如果当前方法有事务，则在嵌套事务内执行。</li><li>如果当前方法没有事务，则与 <code>PROPAGATION_REQUIRED</code> 行为相同。</li><li><strong>场景：适用于可能需要回滚到某个中间状态的操作。例如，在一个复杂的业务流程中，某些子操作失败时，可能需要回滚到子操作之前的状态，而不是整个事务。</strong></li></ul></li></ul><p>在订单支付操作中, 整个流程默认 Propagation.REQUIRED ， 但是在支付过程中，没必要再开启一个新事务，采用了子事务的单独处理回滚，所以这里采用了 Propagation.NESTED 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Transactional(propagation = Propagation.REQUIRED)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processOrder</span><span class="hljs-params">(Order order)</span> &#123;<br>    saveOrder(order); <span class="hljs-comment">// 保存订单</span><br>    nestedProcessPayment(order); <span class="hljs-comment">// 处理支付，可能失败但不影响订单保存</span><br>&#125;<br><br><span class="hljs-meta">@Transactional(propagation = Propagation.NESTED)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">nestedProcessPayment</span><span class="hljs-params">(Order order)</span> &#123;<br>    <span class="hljs-comment">// 尝试扣款</span><br>    <span class="hljs-keyword">if</span> (!paymentService.charge(order)) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PaymentException</span>(<span class="hljs-string">&quot;Payment failed&quot;</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>或者一个老赖资金被冻结的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Transactional(propagation = Propagation.REQUIRED)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">transfer</span><span class="hljs-params">(Account from, Account to, BigDecimal amount)</span> &#123;<br>    deductFromAccount(from, amount); <span class="hljs-comment">// 扣款</span><br>    nestedAddToAccount(to, amount);  <span class="hljs-comment">// 加款（嵌套事务）</span><br>&#125;<br><br><span class="hljs-meta">@Transactional(propagation = Propagation.NESTED)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">nestedAddToAccount</span><span class="hljs-params">(Account to, BigDecimal amount)</span> &#123;<br>    <span class="hljs-keyword">if</span> (to.isBlocked()) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AccountBlockedException</span>(<span class="hljs-string">&quot;Target account is blocked&quot;</span>);<br>    &#125;<br>    to.setBalance(to.getBalance().add(amount));<br>    accountRepository.save(to);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="嵌套事务的坑"><a href="#嵌套事务的坑" class="headerlink" title="嵌套事务的坑"></a>嵌套事务的坑</h4><p>嵌套事务依赖于底层数据库是否支持 Savepoint。如果数据库不支持（比如 MySQL 的 MyISAM 引擎），Spring 会抛出异常或无法正确工作。建议使用支持保存点的数据库（如 InnoDB）。</p><p> <strong>这里再看下TransactionDefinition这个常量配置类, 2003年的类，还特么是 interface!</strong><br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">package</span> org.springframework.transaction;<br><br><span class="hljs-keyword">import</span> org.springframework.lang.Nullable;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Interface that defines Spring-compliant transaction properties.</span><br><span class="hljs-comment"> * Based on the propagation behavior definitions analogous to EJB CMT attributes.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * &lt;p&gt;Note that isolation level and timeout settings will not get applied unless</span><br><span class="hljs-comment"> * an actual new transaction gets started. As only &#123;<span class="hljs-doctag">@link</span> #PROPAGATION_REQUIRED&#125;,</span><br><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@link</span> #PROPAGATION_REQUIRES_NEW&#125; and &#123;<span class="hljs-doctag">@link</span> #PROPAGATION_NESTED&#125; can cause</span><br><span class="hljs-comment"> * that, it usually doesn&#x27;t make sense to specify those settings in other cases.</span><br><span class="hljs-comment"> * Furthermore, be aware that not all transaction managers will support those</span><br><span class="hljs-comment"> * advanced features and thus might throw corresponding exceptions when given</span><br><span class="hljs-comment"> * non-default values.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * &lt;p&gt;The &#123;<span class="hljs-doctag">@link</span> #isReadOnly() read-only flag&#125; applies to any transaction context,</span><br><span class="hljs-comment"> * whether backed by an actual resource transaction or operating non-transactionally</span><br><span class="hljs-comment"> * at the resource level. In the latter case, the flag will only apply to managed</span><br><span class="hljs-comment"> * resources within the application, such as a Hibernate &#123;<span class="hljs-doctag">@code</span> Session&#125;.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">TransactionDefinition</span> &#123;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Support a current transaction; create a new one if none exists.</span><br><span class="hljs-comment"> * Analogous to the EJB transaction attribute of the same name.</span><br><span class="hljs-comment"> * &lt;p&gt;This is typically the default setting of a transaction definition,</span><br><span class="hljs-comment"> * and typically defines a transaction synchronization scope.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-variable">PROPAGATION_REQUIRED</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Support a current transaction; execute non-transactionally if none exists.</span><br><span class="hljs-comment"> * Analogous to the EJB transaction attribute of the same name.</span><br><span class="hljs-comment"> * &lt;p&gt;&lt;b&gt;<span class="hljs-doctag">NOTE:</span>&lt;/b&gt; For transaction managers with transaction synchronization,</span><br><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@code</span> PROPAGATION_SUPPORTS&#125; is slightly different from no transaction</span><br><span class="hljs-comment"> * at all, as it defines a transaction scope that synchronization might apply to.</span><br><span class="hljs-comment"> * As a consequence, the same resources (a JDBC &#123;<span class="hljs-doctag">@code</span> Connection&#125;, a</span><br><span class="hljs-comment"> * Hibernate &#123;<span class="hljs-doctag">@code</span> Session&#125;, etc) will be shared for the entire specified</span><br><span class="hljs-comment"> * scope. Note that the exact behavior depends on the actual synchronization</span><br><span class="hljs-comment"> * configuration of the transaction manager!</span><br><span class="hljs-comment"> * &lt;p&gt;In general, use &#123;<span class="hljs-doctag">@code</span> PROPAGATION_SUPPORTS&#125; with care! In particular, do</span><br><span class="hljs-comment"> * not rely on &#123;<span class="hljs-doctag">@code</span> PROPAGATION_REQUIRED&#125; or &#123;<span class="hljs-doctag">@code</span> PROPAGATION_REQUIRES_NEW&#125;</span><br><span class="hljs-comment"> * &lt;i&gt;within&lt;/i&gt; a &#123;<span class="hljs-doctag">@code</span> PROPAGATION_SUPPORTS&#125; scope (which may lead to</span><br><span class="hljs-comment"> * synchronization conflicts at runtime). If such nesting is unavoidable, make sure</span><br><span class="hljs-comment"> * to configure your transaction manager appropriately (typically switching to</span><br><span class="hljs-comment"> * &quot;synchronization on actual transaction&quot;).</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> org.springframework.transaction.support.AbstractPlatformTransactionManager#setTransactionSynchronization</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> org.springframework.transaction.support.AbstractPlatformTransactionManager#SYNCHRONIZATION_ON_ACTUAL_TRANSACTION</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-variable">PROPAGATION_SUPPORTS</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Support a current transaction; throw an exception if no current transaction</span><br><span class="hljs-comment"> * exists. Analogous to the EJB transaction attribute of the same name.</span><br><span class="hljs-comment"> * &lt;p&gt;Note that transaction synchronization within a &#123;<span class="hljs-doctag">@code</span> PROPAGATION_MANDATORY&#125;</span><br><span class="hljs-comment"> * scope will always be driven by the surrounding transaction.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-variable">PROPAGATION_MANDATORY</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Create a new transaction, suspending the current transaction if one exists.</span><br><span class="hljs-comment"> * Analogous to the EJB transaction attribute of the same name.</span><br><span class="hljs-comment"> * &lt;p&gt;&lt;b&gt;<span class="hljs-doctag">NOTE:</span>&lt;/b&gt; Actual transaction suspension will not work out-of-the-box</span><br><span class="hljs-comment"> * on all transaction managers. This in particular applies to</span><br><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@link</span> org.springframework.transaction.jta.JtaTransactionManager&#125;,</span><br><span class="hljs-comment"> * which requires the &#123;<span class="hljs-doctag">@code</span> javax.transaction.TransactionManager&#125; to be</span><br><span class="hljs-comment"> * made available it to it (which is server-specific in standard Java EE).</span><br><span class="hljs-comment"> * &lt;p&gt;A &#123;<span class="hljs-doctag">@code</span> PROPAGATION_REQUIRES_NEW&#125; scope always defines its own</span><br><span class="hljs-comment"> * transaction synchronizations. Existing synchronizations will be suspended</span><br><span class="hljs-comment"> * and resumed appropriately.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> org.springframework.transaction.jta.JtaTransactionManager#setTransactionManager</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-variable">PROPAGATION_REQUIRES_NEW</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Do not support a current transaction; rather always execute non-transactionally.</span><br><span class="hljs-comment"> * Analogous to the EJB transaction attribute of the same name.</span><br><span class="hljs-comment"> * &lt;p&gt;&lt;b&gt;<span class="hljs-doctag">NOTE:</span>&lt;/b&gt; Actual transaction suspension will not work out-of-the-box</span><br><span class="hljs-comment"> * on all transaction managers. This in particular applies to</span><br><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@link</span> org.springframework.transaction.jta.JtaTransactionManager&#125;,</span><br><span class="hljs-comment"> * which requires the &#123;<span class="hljs-doctag">@code</span> javax.transaction.TransactionManager&#125; to be</span><br><span class="hljs-comment"> * made available it to it (which is server-specific in standard Java EE).</span><br><span class="hljs-comment"> * &lt;p&gt;Note that transaction synchronization is &lt;i&gt;not&lt;/i&gt; available within a</span><br><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@code</span> PROPAGATION_NOT_SUPPORTED&#125; scope. Existing synchronizations</span><br><span class="hljs-comment"> * will be suspended and resumed appropriately.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> org.springframework.transaction.jta.JtaTransactionManager#setTransactionManager</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-variable">PROPAGATION_NOT_SUPPORTED</span> <span class="hljs-operator">=</span> <span class="hljs-number">4</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Do not support a current transaction; throw an exception if a current transaction</span><br><span class="hljs-comment"> * exists. Analogous to the EJB transaction attribute of the same name.</span><br><span class="hljs-comment"> * &lt;p&gt;Note that transaction synchronization is &lt;i&gt;not&lt;/i&gt; available within a</span><br><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@code</span> PROPAGATION_NEVER&#125; scope.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-variable">PROPAGATION_NEVER</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Execute within a nested transaction if a current transaction exists,</span><br><span class="hljs-comment"> * behave like &#123;<span class="hljs-doctag">@link</span> #PROPAGATION_REQUIRED&#125; otherwise. There is no</span><br><span class="hljs-comment"> * analogous feature in EJB.</span><br><span class="hljs-comment"> * &lt;p&gt;&lt;b&gt;<span class="hljs-doctag">NOTE:</span>&lt;/b&gt; Actual creation of a nested transaction will only work on</span><br><span class="hljs-comment"> * specific transaction managers. Out of the box, this only applies to the JDBC</span><br><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@link</span> org.springframework.jdbc.datasource.DataSourceTransactionManager&#125;</span><br><span class="hljs-comment"> * when working on a JDBC 3.0 driver. Some JTA providers might support</span><br><span class="hljs-comment"> * nested transactions as well.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> org.springframework.jdbc.datasource.DataSourceTransactionManager</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-variable">PROPAGATION_NESTED</span> <span class="hljs-operator">=</span> <span class="hljs-number">6</span>;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Use the default isolation level of the underlying datastore.</span><br><span class="hljs-comment"> * All other levels correspond to the JDBC isolation levels.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> java.sql.Connection</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-variable">ISOLATION_DEFAULT</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Indicates that dirty reads, non-repeatable reads and phantom reads</span><br><span class="hljs-comment"> * can occur.</span><br><span class="hljs-comment"> * &lt;p&gt;This level allows a row changed by one transaction to be read by another</span><br><span class="hljs-comment"> * transaction before any changes in that row have been committed (a &quot;dirty read&quot;).</span><br><span class="hljs-comment"> * If any of the changes are rolled back, the second transaction will have</span><br><span class="hljs-comment"> * retrieved an invalid row.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> java.sql.Connection#TRANSACTION_READ_UNCOMMITTED</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-variable">ISOLATION_READ_UNCOMMITTED</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;  <span class="hljs-comment">// same as java.sql.Connection.TRANSACTION_READ_UNCOMMITTED;</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Indicates that dirty reads are prevented; non-repeatable reads and</span><br><span class="hljs-comment"> * phantom reads can occur.</span><br><span class="hljs-comment"> * &lt;p&gt;This level only prohibits a transaction from reading a row</span><br><span class="hljs-comment"> * with uncommitted changes in it.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> java.sql.Connection#TRANSACTION_READ_COMMITTED</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-variable">ISOLATION_READ_COMMITTED</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;  <span class="hljs-comment">// same as java.sql.Connection.TRANSACTION_READ_COMMITTED;</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Indicates that dirty reads and non-repeatable reads are prevented;</span><br><span class="hljs-comment"> * phantom reads can occur.</span><br><span class="hljs-comment"> * &lt;p&gt;This level prohibits a transaction from reading a row with uncommitted changes</span><br><span class="hljs-comment"> * in it, and it also prohibits the situation where one transaction reads a row,</span><br><span class="hljs-comment"> * a second transaction alters the row, and the first transaction re-reads the row,</span><br><span class="hljs-comment"> * getting different values the second time (a &quot;non-repeatable read&quot;).</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> java.sql.Connection#TRANSACTION_REPEATABLE_READ</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-variable">ISOLATION_REPEATABLE_READ</span> <span class="hljs-operator">=</span> <span class="hljs-number">4</span>;  <span class="hljs-comment">// same as java.sql.Connection.TRANSACTION_REPEATABLE_READ;</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Indicates that dirty reads, non-repeatable reads and phantom reads</span><br><span class="hljs-comment"> * are prevented.</span><br><span class="hljs-comment"> * &lt;p&gt;This level includes the prohibitions in &#123;<span class="hljs-doctag">@link</span> #ISOLATION_REPEATABLE_READ&#125;</span><br><span class="hljs-comment"> * and further prohibits the situation where one transaction reads all rows that</span><br><span class="hljs-comment"> * satisfy a &#123;<span class="hljs-doctag">@code</span> WHERE&#125; condition, a second transaction inserts a row</span><br><span class="hljs-comment"> * that satisfies that &#123;<span class="hljs-doctag">@code</span> WHERE&#125; condition, and the first transaction</span><br><span class="hljs-comment"> * re-reads for the same condition, retrieving the additional &quot;phantom&quot; row</span><br><span class="hljs-comment"> * in the second read.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> java.sql.Connection#TRANSACTION_SERIALIZABLE</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-variable">ISOLATION_SERIALIZABLE</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>;  <span class="hljs-comment">// same as java.sql.Connection.TRANSACTION_SERIALIZABLE;</span><br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Use the default timeout of the underlying transaction system,</span><br><span class="hljs-comment"> * or none if timeouts are not supported.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-variable">TIMEOUT_DEFAULT</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br><br>***********************<br>&#125;<br></code></pre></td></tr></table></figure></p><p>理论上， TransactionDefinition 这个接口定义了 Spring 事务的属性，包括传播行为、隔离级别、超时等。</p><p>Propagation 枚举类定义了 Spring 事务传播行为，包括 REQUIRED、SUPPORTS、MANDATORY、REQUIRES_NEW、NOT_SUPPORTED、NEVER、NESTED 等。</p><p>ISOLATION_DEFAULT、ISOLATION_READ_UNCOMMITTED、ISOLATION_READ_COMMITTED、ISOLATION_REPEATABLE_READ、ISOLATION_SERIALIZABLE 这几个常量定义了 Spring 事务的隔离级别。</p><p>TIMEOUT_DEFAULT 常量定义了 Spring 事务的超时时间。</p><p>这里的枚举类和常量类都是 Spring 事务的基础，可以根据实际情况进行配置。</p><h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2><p>@Transactional 作用在 <strong>类</strong> 和 <strong>public方法</strong> 和并<strong>不被推荐</strong>的 <strong>interface</strong> ，作用范围顾名思义。其默认配置回滚 RunTimeException 及其子类，也可以直接指定 回滚 Exceptioin 及其子类：<code>@Transactional(rollbackFor = Exception.class) </code></p><p>或者指定事务传播行为：<code>@Transactional(propagation = Propagation.REQUIRED)</code></p><p>或者指定事务隔离级别：<code>@Transactional(isolation = Isolation.SERIALIZABLE)</code></p><p>或者指定事务超时时间：<code>@Transactional(timeout = 30)</code></p><p>或者指定事务传播行为、隔离级别、超时时间,回滚异常类：<code>@Transactional(propagation = Propagation.REQUIRED, isolation = Isolation.SERIALIZABLE, timeout = 30,rollbackFor = Exception.class)</code></p><hr><h2 id="事务管理器-（编程式事务管理）"><a href="#事务管理器-（编程式事务管理）" class="headerlink" title="事务管理器 （编程式事务管理）"></a>事务管理器 （编程式事务管理）</h2><p>Spring 事务管理器是 Spring 事务的核心，负责事务的提交、回滚、资源的获取和释放等事务管理操作。</p><p>Spring 提供了多种事务管理器，包括 DataSourceTransactionManager、HibernateTransactionManager、JpaTransactionManager、JtaTransactionManager 等。</p><p>DataSourceTransactionManager 用于管理 JDBC 事务，它会自动获取 JDBC Connection，并对 Connection 进行事务的提交、回滚、关闭等操作。</p><p>HibernateTransactionManager 用于管理 Hibernate 事务，它会自动获取 Hibernate Session，并对 Session 进行事务的提交、回滚、关闭等操作。</p><p>JpaTransactionManager 用于管理 JPA 事务，它会自动获取 JPA EntityManager，并对 EntityManager 进行事务的提交、回滚、关闭等操作。</p><p>Spring 事务管理器的配置如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;transactionManager&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.orm.jpa.JpaTransactionManager&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;entityManagerFactory&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;entityManagerFactory&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;entityManagerFactory&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dataSource&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;jpaVendorAdapter&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;jpaVendorAdapter&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;packagesToScan&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.example.entity&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;jpaVendorAdapter&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;database&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;MYSQL&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;showSql&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driverClassName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;root&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;root&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="声明式事务调用方式"><a href="#声明式事务调用方式" class="headerlink" title="声明式事务调用方式"></a>声明式事务调用方式</h3><h3 id="Transactional-注解失效场景"><a href="#Transactional-注解失效场景" class="headerlink" title="@Transactional 注解失效场景"></a>@Transactional 注解失效场景</h3><h4 id="1-方法调用为内部调用（非代理调用）"><a href="#1-方法调用为内部调用（非代理调用）" class="headerlink" title="1.方法调用为内部调用（非代理调用）"></a>1.方法调用为内部调用（非代理调用）</h4><p>pring 的事务管理是基于 AOP（面向切面编程）实现的，默认通过动态代理（JDK 代理或 CGLIB 代理）增强目标类。如果在同一个类中，方法 A 调用方法 B，而 @Transactional 注解在方法 B 上，由于<strong>没有经过代理</strong>，事务不会生效。</p><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyService</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodA</span><span class="hljs-params">()</span> &#123;<br>        methodB(); <span class="hljs-comment">// 直接内部调用</span><br>    &#125;<br><br>    <span class="hljs-meta">@Transactional</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodB</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 事务逻辑</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是我想通过直接在类中进行内部调用如何，该怎样操作呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyService</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodA</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">//</span><br><span class="hljs-type">MyService</span> <span class="hljs-variable">myService</span> <span class="hljs-operator">=</span> (MyService) AopContext.currentProxy();<br>        myService.methodB(); <span class="hljs-comment">// 直接内部调用</span><br>    &#125;<br><br>    <span class="hljs-meta">@Transactional</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodB</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 事务逻辑</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="方法不是-public-的"><a href="#方法不是-public-的" class="headerlink" title="方法不是 public 的"></a>方法不是 public 的</h4><p>Spring AOP 只能代理 public 方法。如果 @Transactional 注解标注在非 public 方法上（例如 private 或 protected），事务不会生效。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyService</span> &#123;<br>    <span class="hljs-meta">@Transactional</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">myMethod</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 事务逻辑 (私有方法不生效)</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="异常被捕获但未抛出"><a href="#异常被捕获但未抛出" class="headerlink" title="异常被捕获但未抛出"></a>异常被捕获但未抛出</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Transactional</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">myMethod</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 可能抛出异常的操作</span><br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        <span class="hljs-comment">// 异常被捕获，未抛出 not throwing the exception</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="事务传播行为不生效"><a href="#事务传播行为不生效" class="headerlink" title="事务传播行为不生效"></a>事务传播行为不生效</h4><p>事务传播属性配置不当<br>原因：@Transactional 的 propagation 属性默认是 Propagation.REQUIRED，表示如果当前存在事务则加入，不存在则新建事务。如果设置为 PROPAGATION_SUPPORTS、PROPAGATION_NOT_SUPPORTED、 PROPAGATION_NEVER，则事务不会生效。<br>这些单独配置且方法外部上级方法没有配置事务，都会造成方法内的事务不生效。</p><h4 id="数据库引擎不支持事务"><a href="#数据库引擎不支持事务" class="headerlink" title="数据库引擎不支持事务"></a>数据库引擎不支持事务</h4><h4 id="多线程导致事务失效"><a href="#多线程导致事务失效" class="headerlink" title="多线程导致事务失效"></a>多线程导致事务失效</h4><p>Spring 的事务是基于 ThreadLocal 实现的，每个线程有独立的事务上下文。如果在方法中开启新线程执行数据库操作，新线程无法继承原线程的事务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Transactional</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">myMethod</span><span class="hljs-params">()</span> &#123;<br>myRepository.save(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Entity</span>(<span class="hljs-string">&quot;Step 1&quot;</span>)); <span class="hljs-comment">// 主线程的事务上下文</span><br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-comment">// 数据库操作在新线程中，无法使用事务</span><br>    &#125;).start();<br><br>CompletableFuture.runAsync(() -&gt; &#123;<br>myRepository.save(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Entity</span>(<span class="hljs-string">&quot;Step 2&quot;</span>)); <span class="hljs-comment">// 在新线程中执行</span><br>&#125;);<br><br>Future&lt;?&gt; future = executorService.submit(() -&gt; &#123;<br>            myRepository.save(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Entity</span>(<span class="hljs-string">&quot;Step 3&quot;</span>)); <span class="hljs-comment">// 在新线程中执行</span><br>        &#125;);<br>        future.get(); <span class="hljs-comment">// 等待任务完成</span><br><br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Rollback&quot;</span>); <span class="hljs-comment">// 模拟异常回滚</span><br>&#125;<br></code></pre></td></tr></table></figure><p>CompletableFuture.runAsync 默认使用 ForkJoinPool.commonPool() 执行任务，新线程没有继承主线程的 TransactionManager 的 ThreadLocal 事务上下文，导致事务失效。</p><p>Future 通过线程池执行任务时，新线程无法访问主线程的 ThreadLocal 事务状态，因此事务失效。</p><h5 id="解决方式"><a href="#解决方式" class="headerlink" title="解决方式"></a>解决方式</h5><ul><li>使用编程式事务管理<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyService</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> MyRepository myRepository;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> TransactionTemplate transactionTemplate;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">myTransactionalMethod</span><span class="hljs-params">()</span> &#123;<br>        transactionTemplate.execute(status -&gt; &#123;<br>            myRepository.save(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Entity</span>(<span class="hljs-string">&quot;Step 1&quot;</span>));<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;);<br><br>        CompletableFuture.runAsync(() -&gt; &#123;<br>            transactionTemplate.execute(status -&gt; &#123;<br>                myRepository.save(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Entity</span>(<span class="hljs-string">&quot;Step 2&quot;</span>));<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            &#125;);<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>这种方式每个异步任务有独立的事务，无法保证整体一致性。如果需要整体回滚，需结合其他机制（如补偿逻辑）。</li></ul><h5 id="传递事务上下文到新线程"><a href="#传递事务上下文到新线程" class="headerlink" title="传递事务上下文到新线程"></a>传递事务上下文到新线程</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyService</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> MyRepository myRepository;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> PlatformTransactionManager transactionManager;<br><br>    <span class="hljs-meta">@Transactional</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">myTransactionalMethod</span><span class="hljs-params">()</span> &#123;<br>        myRepository.save(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Entity</span>(<span class="hljs-string">&quot;Step 1&quot;</span>));<br><br>        <span class="hljs-type">TransactionDefinition</span> <span class="hljs-variable">definition</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultTransactionDefinition</span>();<br>        <span class="hljs-type">TransactionStatus</span> <span class="hljs-variable">status</span> <span class="hljs-operator">=</span> transactionManager.getTransaction(definition);<br><br>        CompletableFuture.runAsync(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                myRepository.save(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Entity</span>(<span class="hljs-string">&quot;Step 2&quot;</span>));<br>                transactionManager.commit(status); <span class="hljs-comment">// 手动提交</span><br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                transactionManager.rollback(status); <span class="hljs-comment">// 手动回滚</span><br>            &#125;<br>        &#125;);<br><br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Rollback&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过 TransactionSynchronizationManager 保存主线程的事务状态到子线程中再恢复。</p><ul><li>尽量避免在事务方法中引入异步操作。</li><li><strong>如果必须异步，可以使用编程式事务管理或传递事务上下文，但需权衡复杂度和一致性需求。</strong></li></ul><h4 id="未启用事务管理器-Spring-需要考虑-，Spring-Boot-自动配置"><a href="#未启用事务管理器-Spring-需要考虑-，Spring-Boot-自动配置" class="headerlink" title="未启用事务管理器(Spring 需要考虑 ，Spring Boot 自动配置)"></a>未启用事务管理器(Spring 需要考虑 ，Spring Boot 自动配置)</h4><p>原因：如果项目中没有配置 @EnableTransactionManagement 或缺少事务管理器（DataSourceTransactionManager）的 Bean，@Transactional 将不起作用。<br>解决办法：<br>在配置类上添加 @EnableTransactionManagement。<br>确保正确配置数据源和事务管理器：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;transactionManager&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.orm.jpa.JpaTransactionManager&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;entityManagerFactory&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;entityManagerFactory&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;entityManagerFactory&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dataSource&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;jpaVendorAdapter&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;jpaVendorAdapter&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;packagesToScan&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.example.entity&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;jpaVendorAdapter&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;database&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;MYSQL&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;showSql&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driverClassName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;root&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;root&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>或者 ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> PlatformTransactionManager <span class="hljs-title function_">transactionManager</span><span class="hljs-params">(DataSource dataSource)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataSourceTransactionManager</span>(dataSource);<br>&#125;<br></code></pre></td></tr></table></figure><p>Spring Boot 自动配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java">类来自 <span class="hljs-meta">@SpringBootApplication</span> =&gt; <span class="hljs-meta">@EnableAutoConfiguration</span> =&gt; <span class="hljs-meta">@Import(AutoConfigurationImportSelector.class)</span><br><br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;<br><span class="hljs-keyword">if</span> (!isEnabled(annotationMetadata)) &#123;<br><span class="hljs-keyword">return</span> NO_IMPORTS;<br>&#125;<br><span class="hljs-type">AutoConfigurationEntry</span> <span class="hljs-variable">autoConfigurationEntry</span> <span class="hljs-operator">=</span> getAutoConfigurationEntry(annotationMetadata);<br><span class="hljs-keyword">return</span> StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());<br>&#125;<br><br><span class="hljs-keyword">protected</span> AutoConfigurationEntry <span class="hljs-title function_">getAutoConfigurationEntry</span><span class="hljs-params">(AnnotationMetadata annotationMetadata)</span> &#123;<br><span class="hljs-keyword">if</span> (!isEnabled(annotationMetadata)) &#123;<br><span class="hljs-keyword">return</span> EMPTY_ENTRY;<br>&#125;<br><span class="hljs-type">AnnotationAttributes</span> <span class="hljs-variable">attributes</span> <span class="hljs-operator">=</span> getAttributes(annotationMetadata);<br>List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes);<br>configurations = removeDuplicates(configurations);<br>Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes);<br>checkExcludedClasses(configurations, exclusions);<br>configurations.removeAll(exclusions);<br>configurations = getConfigurationClassFilter().filter(configurations);<br>fireAutoConfigurationImportEvents(configurations, exclusions);<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AutoConfigurationEntry</span>(configurations, exclusions);<br>&#125;<br><br><span class="hljs-keyword">protected</span> List&lt;String&gt; <span class="hljs-title function_">getCandidateConfigurations</span><span class="hljs-params">(AnnotationMetadata metadata, AnnotationAttributes attributes)</span> &#123;<br>List&lt;String&gt; configurations = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>(SpringFactoriesLoader.loadFactoryNames(<span class="hljs-built_in">this</span>.getSpringFactoriesLoaderFactoryClass(), <span class="hljs-built_in">this</span>.getBeanClassLoader()));<br>ImportCandidates.load(AutoConfiguration.class, <span class="hljs-built_in">this</span>.getBeanClassLoader()).forEach(configurations::add);<br>Assert.notEmpty(configurations, <span class="hljs-string">&quot;No auto configuration classes found in META-INF/spring.factories nor in META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports. If you are using a custom packaging, make sure that file is correct.&quot;</span>);<br><span class="hljs-keyword">return</span> configurations;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里去找 META-INF&#x2F;spring.factories 文件</p><p>嗯，啥都没有<br>但是在下方有个类似的同名文件： <code>spring-autoconfigure-metadata.properties</code><br>看下被谁引用了: AutoConfigurationMetadataLoader</p><p>调用方也是 AutoConfigurationImportSelector</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> AutoConfigurationMetadata <span class="hljs-title function_">getAutoConfigurationMetadata</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.autoConfigurationMetadata == <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-built_in">this</span>.autoConfigurationMetadata = AutoConfigurationMetadataLoader.loadMetadata(<span class="hljs-built_in">this</span>.beanClassLoader);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.autoConfigurationMetadata;<br>&#125;<br></code></pre></td></tr></table></figure><p>继续向上追查</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;<br><span class="hljs-keyword">if</span> (!isEnabled(annotationMetadata)) &#123;<br><span class="hljs-keyword">return</span> NO_IMPORTS;<br>&#125;<br><span class="hljs-type">AutoConfigurationEntry</span> <span class="hljs-variable">autoConfigurationEntry</span> <span class="hljs-operator">=</span> getAutoConfigurationEntry(annotationMetadata);<br><span class="hljs-keyword">return</span> StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Iterable&lt;Entry&gt; <span class="hljs-title function_">selectImports</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.autoConfigurationEntries.isEmpty()) &#123;<br><span class="hljs-keyword">return</span> Collections.emptyList();<br>&#125;<br>Set&lt;String&gt; allExclusions = <span class="hljs-built_in">this</span>.autoConfigurationEntries.stream()<br>.map(AutoConfigurationEntry::getExclusions).flatMap(Collection::stream).collect(Collectors.toSet());<br>Set&lt;String&gt; processedConfigurations = <span class="hljs-built_in">this</span>.autoConfigurationEntries.stream()<br>.map(AutoConfigurationEntry::getConfigurations).flatMap(Collection::stream)<br>.collect(Collectors.toCollection(LinkedHashSet::<span class="hljs-keyword">new</span>));<br>processedConfigurations.removeAll(allExclusions);<br><br><span class="hljs-comment">// 这里调用了  getAutoConfigurationMetadata 方法</span><br><span class="hljs-keyword">return</span> sortAutoConfigurations(processedConfigurations, getAutoConfigurationMetadata()).stream()<br>.map((importClassName) -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>(<span class="hljs-built_in">this</span>.entries.get(importClassName), importClassName))<br>.collect(Collectors.toList());<br>&#125;<br></code></pre></td></tr></table></figure><p>注意。这里有两个 selectImports 方法，第一个属于 <code>ImportSelector</code> 第二个属于 <code>DeferredImportSelector</code>。<br>DeferredImportSelector 接口 又继承了 ImportSelector。</p><p><strong>DeferredImportSelector 作为 ImportSelector 的延迟实现，在 ApplicationContext 初始化时，会调用 selectImports 方法，而 selectImports 方法又会调用DeferredImportSelector 的 getAutoConfigurationEntry 方法。</strong></p><p>DeferredImportSelector 里还有 group 方法，属于是逐步为 ImportSelector 细化解析流程<br>然后来看下 <code>spring-autoconfigure-metadata.properties</code> 里是如何配置的：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs sh">org.springframework.boot.autoconfigure.batch.BatchConfigurerConfiguration.ConditionalOnClass=org.springframework.transaction.PlatformTransactionManager<br>org.springframework.boot.autoconfigure.data.jdbc.JdbcRepositoriesAutoConfiguration.ConditionalOnBean=org.springframework.jdbc.core.namedparam.NamedParameterJdbcOperations,org.springframework.transaction.PlatformTransactionManager<br><br><br>org.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration=<br>org.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration<span class="hljs-variable">$EnableTransactionManagementConfiguration</span>=<br>org.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration<span class="hljs-variable">$EnableTransactionManagementConfiguration</span>.ConditionalOnBean=org.springframework.transaction.TransactionManager<br>org.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration<span class="hljs-variable">$TransactionTemplateConfiguration</span>=<br>org.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration<span class="hljs-variable">$TransactionTemplateConfiguration</span>.ConditionalOnSingleCandidate=org.springframework.transaction.PlatformTransactionManager<br>org.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration.AutoConfigureAfter=org.springframework.boot.autoconfigure.transaction.jta.JtaAutoConfiguration,org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration,org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration,org.springframework.boot.autoconfigure.data.neo4j.Neo4jDataAutoConfiguration<br>org.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration.ConditionalOnClass=org.springframework.transaction.PlatformTransactionManager<br>org.springframework.boot.autoconfigure.transaction.jta.AtomikosJtaConfiguration=<br>org.springframework.boot.autoconfigure.transaction.jta.AtomikosJtaConfiguration<span class="hljs-variable">$AtomikosJtaJmsConfiguration</span>=<br>org.springframework.boot.autoconfigure.transaction.jta.AtomikosJtaConfiguration<span class="hljs-variable">$AtomikosJtaJmsConfiguration</span>.ConditionalOnClass=javax.jms.Message<br>org.springframework.boot.autoconfigure.transaction.jta.AtomikosJtaConfiguration.ConditionalOnClass=com.atomikos.icatch.jta.UserTransactionManager,org.springframework.transaction.jta.JtaTransactionManager<br>org.springframework.boot.autoconfigure.transaction.jta.JndiJtaConfiguration=<br>org.springframework.boot.autoconfigure.transaction.jta.JndiJtaConfiguration.ConditionalOnClass=org.springframework.transaction.jta.JtaTransactionManager<br>org.springframework.boot.autoconfigure.transaction.jta.JtaAutoConfiguration=<br>org.springframework.boot.autoconfigure.transaction.jta.JtaAutoConfiguration.AutoConfigureBefore=org.springframework.boot.autoconfigure.jdbc.XADataSourceAutoConfiguration,org.springframework.boot.autoconfigure.jms.activemq.ActiveMQAutoConfiguration,org.springframework.boot.autoconfigure.jms.artemis.ArtemisAutoConfiguration,org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration<br>org.springframework.boot.autoconfigure.transaction.jta.JtaAutoConfiguration.ConditionalOnClass=javax.transaction.Transaction<br></code></pre></td></tr></table></figure><p>直接AI 解释下：</p><h5 id="1-org-springframework-boot-autoconfigure-transaction-TransactionAutoConfiguration"><a href="#1-org-springframework-boot-autoconfigure-transaction-TransactionAutoConfiguration" class="headerlink" title="1. org.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration"></a>1. org.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration</h5><p>这是 Spring Boot 提供的事务管理的自动配置类。它负责在适当的条件下自动配置事务相关的 bean，比如 TransactionManager 和 TransactionTemplate。</p><p>ConditionalOnClass&#x3D;org.springframework.transaction.PlatformTransactionManager<br>这个注解表示该自动配置类只有在类路径中存在 PlatformTransactionManager（Spring 的事务管理核心接口）时才会生效。这是 Spring Boot 条件配置的典型用法，确保只有在事务管理相关依赖存在时才启用配置。<br>AutoConfigureAfter&#x3D;…<br>表示这个配置类会在指定的其他自动配置类（如 JtaAutoConfiguration, HibernateJpaAutoConfiguration, DataSourceTransactionManagerAutoConfiguration 等）之后执行。这确保事务管理的配置能够依赖于数据库、JPA 或 JTA 的配置完成后再生效。</p><h5 id="2-TransactionAutoConfiguration-EnableTransactionManagementConfiguration"><a href="#2-TransactionAutoConfiguration-EnableTransactionManagementConfiguration" class="headerlink" title="2. TransactionAutoConfiguration$EnableTransactionManagementConfiguration"></a>2. TransactionAutoConfiguration$EnableTransactionManagementConfiguration</h5><p>这是 TransactionAutoConfiguration 的一个内部配置类，专门处理 @EnableTransactionManagement 相关的配置（比如支持 @Transactional 注解）。</p><p>ConditionalOnBean&#x3D;org.springframework.transaction.TransactionManager<br>表示这个配置只有在容器中存在 TransactionManager bean 时才会生效。TransactionManager 是事务管理的核心组件，可能由其他配置（如 JDBC、JPA 或 JTA）提供。</p><h5 id="3-TransactionAutoConfiguration-TransactionTemplateConfiguration"><a href="#3-TransactionAutoConfiguration-TransactionTemplateConfiguration" class="headerlink" title="3. TransactionAutoConfiguration$TransactionTemplateConfiguration"></a>3. TransactionAutoConfiguration$TransactionTemplateConfiguration</h5><p>这是另一个内部配置类，负责配置 TransactionTemplate，它是一个用于编程式事务管理的工具。</p><p>ConditionalOnSingleCandidate&#x3D;org.springframework.transaction.PlatformTransactionManager<br>表示只有当容器中存在单一候选的 PlatformTransactionManager 时，这个配置才会生效。如果有多个 PlatformTransactionManager bean（比如同时配置了 JPA 和 JDBC 的事务管理器），Spring Boot 不会自动配置 TransactionTemplate，以避免歧义。</p><h5 id="4-org-springframework-boot-autoconfigure-transaction-jta-JtaAutoConfiguration"><a href="#4-org-springframework-boot-autoconfigure-transaction-jta-JtaAutoConfiguration" class="headerlink" title="4. org.springframework.boot.autoconfigure.transaction.jta.JtaAutoConfiguration"></a>4. org.springframework.boot.autoconfigure.transaction.jta.JtaAutoConfiguration</h5><p>这是 JTA（Java Transaction API，分布式事务）的自动配置类，适用于需要分布式事务的场景。它会根据不同的 JTA 实现（比如 Atomikos 或 JNDI）进行配置。</p><p>ConditionalOnClass&#x3D;javax.transaction.Transaction<br>表示只有在类路径中存在 javax.transaction.Transaction（JTA 的核心接口）时，这个配置才会生效。<br>AutoConfigureBefore&#x3D;…<br>表示这个配置会在一些其他自动配置类（如 XADataSourceAutoConfiguration, HibernateJpaAutoConfiguration 等）之前执行。这是因为 JTA 事务管理需要先于数据源或 ORM 配置完成。</p><h5 id="5-org-springframework-boot-autoconfigure-transaction-jta-AtomikosJtaConfiguration"><a href="#5-org-springframework-boot-autoconfigure-transaction-jta-AtomikosJtaConfiguration" class="headerlink" title="5. org.springframework.boot.autoconfigure.transaction.jta.AtomikosJtaConfiguration"></a>5. org.springframework.boot.autoconfigure.transaction.jta.AtomikosJtaConfiguration</h5><p>这是 JTA 配置的一个子类，专门为 Atomikos（一个流行的 JTA 事务管理器实现）提供支持。</p><p>ConditionalOnClass&#x3D;com.atomikos.icatch.jta.UserTransactionManager,org.springframework.transaction.jta.JtaTransactionManager</p><p>表示只有在类路径中存在 Atomikos 的 UserTransactionManager 和 Spring 的 JtaTransactionManager 时，这个配置才会生效。这是确保 Atomikos 依赖可用。</p><p>AtomikosJtaConfiguration$AtomikosJtaJmsConfiguration</p><p>这是 Atomikos 配置的子类，专门处理 JMS（Java Message Service）的事务支持。</p><p>ConditionalOnClass&#x3D;javax.jms.Message<br>表示只有在类路径中存在 JMS 的 Message 类时，这个 JMS 相关配置才会生效。</p><h5 id="6-org-springframework-boot-autoconfigure-transaction-jta-JndiJtaConfiguration"><a href="#6-org-springframework-boot-autoconfigure-transaction-jta-JndiJtaConfiguration" class="headerlink" title="6. org.springframework.boot.autoconfigure.transaction.jta.JndiJtaConfiguration"></a>6. org.springframework.boot.autoconfigure.transaction.jta.JndiJtaConfiguration</h5><p>这是另一个 JTA 配置子类，用于通过 JNDI（Java Naming and Directory Interface）查找事务管理器，通常在应用服务器（如 WebSphere、WebLogic）中使用。</p><p>ConditionalOnClass&#x3D;org.springframework.transaction.jta.JtaTransactionManager<br>表示只有在类路径中存在 JtaTransactionManager 时，这个配置才会生效。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>这些配置类的作用是：</p><ul><li>模块化事务支持：Spring Boot 根据类路径中的依赖（如 JDBC、JPA、JTA、Atomikos 等）自动配置事务管理。</li><li>条件化加载：通过 ConditionalOnClass、ConditionalOnBean 等注解，确保只有在必要依赖存在时才启用相关配置，避免不必要的加载。</li><li>顺序控制：通过 AutoConfigureAfter 和 AutoConfigureBefore 控制配置的执行顺序，确保依赖关系正确。</li><li>灵活性：支持不同的使用场景，比如编程式事务（TransactionTemplate）、声明式事务（@Transactional）、分布式事务（JTA）等。</li></ul><h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
    
    
    <categories>
      
      <category>develop</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spting</tag>
      
      <tag>Transactional</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「升维思考」是自我改变的本质根源</title>
    <link href="/2025/03/01/%E3%80%8C%E5%8D%87%E7%BB%B4%E6%80%9D%E8%80%83%E3%80%8D%E6%98%AF%E8%87%AA%E6%88%91%E6%94%B9%E5%8F%98%E7%9A%84%E6%9C%AC%E8%B4%A8%E6%A0%B9%E6%BA%90/"/>
    <url>/2025/03/01/%E3%80%8C%E5%8D%87%E7%BB%B4%E6%80%9D%E8%80%83%E3%80%8D%E6%98%AF%E8%87%AA%E6%88%91%E6%94%B9%E5%8F%98%E7%9A%84%E6%9C%AC%E8%B4%A8%E6%A0%B9%E6%BA%90/</url>
    
    <content type="html"><![CDATA[<p>看到有同志在坚持 Campsite Rule 类 「 3-2-1 」写作方法（具体可在🧲 PPS 内查看），且内容一天比一天有质量，我比较欣慰。其实这些“小事”只要你坚持，只要你学会「升维思考」（增加思考的深度和广度），自然可以。</p><p>比如有同志谈到自己的焦虑，有年龄上的、也有工作上的。我说「挺好的」。焦虑是一种警示机制，如果没有焦虑，那么你会平平淡淡过每一天。早晨挤地铁上班，晚上加班打车回家。在公司里忙忙碌碌一年，为升职加薪努力，期间不问任何缘由。直到有一天，你所预想的事情没有发生，比如没有按照预期时间升职，而那些你不想要的东西（比如年龄渐长，家庭压力变大）却日渐逼近，你会觉得焦虑。</p><p>当你开始焦虑，你才会有精力认真思考一下未来，思考一下自己目前的道路。人本质上是偏于安逸，懒于思考的。</p><p>王兴曾经引用过一句话「多数人为了逃避真正的思考是愿意做任何事情的」。这句话虽然残酷，但非常真实。</p><p>不信你问问自己在过去的三个月是否深思过。只有焦虑，真正痛彻的焦虑感才会逼你开始思考。这是人的劣根性所致，当然也可以好好利用。比如利用焦虑真正逼迫自己思考未来，思考自己，思考选择。</p><p>👨‍🌾当你开始真正思考时，我有以下建议给你：</p><p>当下的困惑，要提升一个层次去思考，然后再回过来解决问题。这就是所谓的升维思考，降维攻击（行动）。比如你工作遇到困惑，就去思考你的择业原则；经济上紧张，就去想清楚如何获得财务自由。站在更高的维度去看自己当下的困难，都要容易很多。每一个困难成为新的触发契机，而现实问题的解决不过是「升维思考，降维攻击」的副产品而已。</p><p>有些根本性的问题想清楚时，日常工作、生活中碰到的问题只能掀起很小的涟漪。这和长途驾驶的经历非常像，当你的目标是千里之外时，在该慢慢等待的拥堵路段（比如节假日时的省界收费站）你会非常耐心地等待，因为这在整个长途过程中，小段的拥堵是无可避免、但又无关大局的。</p><p>简而言之，「升维思考」是从具体问题中跳出来，尝试去解决更高层的问题、更长期的问题、更根本的问题，甚至是更多人的问题。乍一看，我们在提升问题的难度。但是通过升维，我们会忽略一些无关紧要的细节，把眼睛聚焦在真正关键的问题上，反而简化了问题。并且通过升维，问题本身的意义得以深化，我们被迫做更深刻的思考，而「改变」本身的动力也更为持久。这就是「升维思考」之所以有效的方法之一。</p><p>当你眼中只有当下、只有自己时，烦恼、焦虑甚至是痛苦可能会让你无法呼吸，找不到出路。但是一旦你跳出当下、跳出小我之后，反而具有了“上帝视角”。你从「只见自己」向「看到众生」和「看到终身」转变。你不是在解决此时此刻的问题，你是在解决长期的问题；你不是在解决小我的问题，你是在解决大家的问题。你的思考有了更深刻的意义。</p><p>当头脑逐渐澄明，前途清晰的时候，选择和行为就会变得简单。也就是说，当你能搞定「升维思考」时，自然就搞定了「降维攻击」。想与做融为了一体，割裂不再，问题自然解决。</p><p>到此为止，任何不能毁灭你的，都是具体的困难，只不过给你提供了深刻思考的机会，让你有机会解决更长期和更广泛的问题。而深刻的思考必然带来强大而坚定的行动力，自然会让你变得更强大。</p><p>这样的思考角度不仅会让你在面对当下难题时豁然开朗，更给了你创造更大价值的可能。举个例子，如果你只是解决了自己容易焦虑的问题，那么只对自己的身心健康有价值，但是如果你能解决一类人的焦虑问题，你的体验和认知就对这一类人产生价值。如果你只是解决了个人的财务危机，那么只对个人或者自己的家庭有帮助，但是如果你能提出一种比较通用的、获得财务自由的方法，那么就给更多人创造了价值。换言之，这些人会愿意付费来听你分享。</p><p>当然，这个世界上除了“死记硬背”还有什么通用的吗？</p><p>回答自然是：没有</p><p>「升维思考」的最大陷阱就是：从思考解决「小我」的困扰延展到去思考更多人的困扰，通过解决一类人的困扰而获得创造更大价值的机会。</p><p>所以你要阶段性，一步一步的去建立自身的「升维思考」，而不是一味提升到“上帝视角”。</p><p>再好比写作，其实每天都有可讲述的故事，只不过你不善于发现、不善于主动思考。</p><p>如果你在这一日内没有任何可以讲述的故事，这一天该多无聊啊，你的人生是多无趣啊！</p><p>其实 聊&#x2F;写 什么话题都可以啊，可以聊自己乏善可陈的学习经历，聊自己找不到工作的窘迫，聊自己的感情，聊自己的婚姻，聊出版社，聊写作，聊疾病，聊死亡。而不是浑浑噩噩又一日，不知满足、不知疲倦，不肯睡觉。</p><p>就好比，我为什么非常厌恶“抖快红”这些平台，一是没有任何价值和营养，二是它们会让你“不肯睡觉”。</p><p>这是一个典型的现代病，其危害远甚于其他现代病，比如高血压，焦虑等等。往前推20年，没有智能手机，吸引我们不睡觉的只有电子游戏，还是单机的居多。再往前推10年，到1990年代，那时候好像睡前只能看些书了。</p><p>虽然没有数据的统计，但我心中认定“不肯睡觉”这件事一定是近几十年才出现的。电子产品、手机、短视频的诱惑只是表象，其背后是我们自我伤害的能力在增强的表现。</p><p>我们已经习惯了随时随地拿着手机，甚至上厕所的时候，也很难控制自己不把手机掏出来 —— 这变成一个需要格外努力才能做到的事情。</p><p>我们也习惯了只要拿起手机，就能随时工作的模式 —— 「没有人要求我们这样，我们自觉养成了这样的习惯。」</p><p>我反复在说“读、写、说&#x2F;聊”是人生的“地基”，是最重要的基础能力。那本质我们的诉求是什么？只是在每一天的24小时中，找到一个片刻，这一片刻的所见所闻所想，值得我们用文字郑重地记下来，留给十年后的自己。</p><p>这代表我们人生的这24小时并没有白白流失 —— 从个人历史（长期主义）的角度，那些没有记录的日子是白白流过的，是值得惋惜的。</p><p>我们可以从不同的角度去审视自己的每一天。哪怕是碎片化的记录，对于十年后的自己，都有意义。</p><p>就是在忙碌中体会无聊，在无聊中寻找意义，在意义中寻找存在的价值和乐趣。</p><p>如同今日和菜头所写《 回某位读者老师的话 (<a href="https://mp.weixin.qq.com/s/FgtZKN1keoF0VPFWW3dyUA">https://mp.weixin.qq.com/s/FgtZKN1keoF0VPFWW3dyUA</a>) 》，虽然意有所指「教育」，但何尝不是审视自身呢？</p><blockquote><p>以下摘录&#x2F;总结 所写《回某位读者老师的话》的内容</p></blockquote><p>培养自身、发展自身，谁都在说。那么具体应该发展什么，为什么而发展，自我发展的标准和方向是什么？可能许多人都没有答案，也不会有统一答案，最大的共识可能只有一句话：钱，更多的钱。</p><p>真的是这样？</p><p>我们不是玄幻仙侠小说里的重生穿越，自带技能点和技能树的。</p><p>我们生下来，就意味着潜能，在这个世界上的绝大部分事情，绝大部分人都能做到。而之所以看起来如此参差不齐，人生的际遇千差万别，除了命运的拨弄之外，最主要的原因是人们能否发现并且激发自己的潜能。也就是说，拿了单程票来到地球，面对这个世界，面对自己的人生，人们还是可以有所作为的。</p><p>👨‍🌾而“读写说教”就是培养我们这种潜能的地基，好比很多同志跟我反应，有些内容太长，看不下去，能不能简短扼要等等。</p><p>还能说啥呢？只能借用和菜头的一句话：“这个第一念不止是会让人看不下去一篇10000字的序言，它所封禁它所阻止它所限制的远远不止是现在的一篇文字。”</p>]]></content>
    
    
    <categories>
      
      <category>Life Co., Ltd.</category>
      
    </categories>
    
    
    <tags>
      
      <tag>life</tag>
      
      <tag>think</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于「觉知」、「致知」和「智识」。</title>
    <link href="/2025/03/01/%E5%85%B3%E4%BA%8E%E3%80%8C%E8%A7%89%E7%9F%A5%E3%80%8D%E3%80%81%E3%80%8C%E8%87%B4%E7%9F%A5%E3%80%8D%E5%92%8C%E3%80%8C%E6%99%BA%E8%AF%86%E3%80%8D%E3%80%82/"/>
    <url>/2025/03/01/%E5%85%B3%E4%BA%8E%E3%80%8C%E8%A7%89%E7%9F%A5%E3%80%8D%E3%80%81%E3%80%8C%E8%87%B4%E7%9F%A5%E3%80%8D%E5%92%8C%E3%80%8C%E6%99%BA%E8%AF%86%E3%80%8D%E3%80%82/</url>
    
    <content type="html"><![CDATA[<p>拥有觉知的人，关心的是事实，因为他们需要确凿无疑的事实来反向观照自己，去思考自己在类似的情境下会有怎样的选择，于是他们通过理解他人的方式来理解自己，通过理解自己的方式宽容他人。没有觉知的人，并不关心事实，他们更关心所谓的动机，具体说起来，就是关心人性中的愚蠢和邪恶。他们需要这些东西，不遗余力地去证明这些东西，然后以此证明自己的正确和道德。” © 和菜头</p><p>👨‍🌾 没有「觉知」，就没有「智识」。</p><p>关于什么是「智识」？可以参考芝加哥大学社会学系教授安德鲁·阿伯特（Andrew Abbott）的演讲 。</p><blockquote><p><a href="https://www.youtube-nocookie.com/embed/fSFkljMNegY">https://www.youtube-nocookie.com/embed/fSFkljMNegY</a></p></blockquote><p>视频很长（一个半小时），总体来说：认知，最重要的不是知识（knowledge），而是致知（knowing）。毕竟，我们将卓越的知识定义为由卓越的致知行为产生的任何知识。所以，致知决定知识。</p><p>所知之事（The Known，致知的客体），有两个重大变化：第一，在我们所知之事中，关于我们自己和我们社会生活的知识远多于其他；第二，对知识的渴望与知识的商品化之间的竞赛，不断地把我们知识的客体分解成的越来越小。而致知的主体，即致知者（The Knower）主要变化是，社会性致知者（Social knower）的兴起，如学术团体、研究机构；自二战以来，组织作为致知者正稳步上升，如Google、Facebook等；第三点，物（如电脑）作为致知者的重要性正不断增强。至于知识本身，也即致知的结果，有一个主要的变化：不是已知事物的量有变化，而是其质有变化，知识越来越像商品——它不再是一个过程，而是结果。</p><p>而在当代，多数人转向社会性致知、「知为寻找」、以算法为致知，日益远离以手艺人独自工作的方式致知、以联想为致知、以话语论证为致知。</p><p>AI的流行，加剧了更多人对「致知」的理解为「寻找」（finding），他们会上网寻找知识的时间比思考的时间要长得多。他们把阅读本身定义为一种寻找。</p><p>这种「知为寻找」的模式与「知识由商品构成」的观念有关，因为商品是可以找到的东西。</p><p>他们关于致知的理解不包括任何真正的论证（argument）。如果你直接问这些某某的论证，他们会给你一个要点列表（列表上甚至会是某某说过的重要内容），但是它们之间没有逻辑 联系&#x2F;关联。因为他们并不真正把论证看成复杂的逻辑句法，他们把它当作一个清单。</p><blockquote><p>犹如上一条内容 ： AI scum (<a href="https://t.me/talkjfh/2840">https://t.me/talkjfh/2840</a>) </p></blockquote><p>致知的最后一个、也许是最重要的变化是话语性的、线性有序（discursive, linearly-ordered）的致知行为作为一种实践的衰落。</p><p>更糟糕的是向视觉致知的转变，比如《抖快红》的流行，但是「视觉再现」并不能有效传达高度复杂的思想，我们不会试图用纯粹的视觉命题来证明微积分基本定理，就像我们不会不用语言来表达哈姆雷特所面临的道德两难一样。</p><p>视觉致知并不是像话语致知那样的智识工具。这就是事实。</p><p>这些东西的产生，与我们的「认知扭曲」和「知识诅咒」（The Curse of Knowledge）均有关系。</p><p>没有「觉知」，就没有「致知」；没有「致知」，就没有「智识」。</p>]]></content>
    
    
    <categories>
      
      <category>Life Co., Ltd.</category>
      
    </categories>
    
    
    <tags>
      
      <tag>life</tag>
      
      <tag>think</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>认知 转换/升级 的闭环效应，创造性思维和注意力管理</title>
    <link href="/2025/03/01/%E8%AE%A4%E7%9F%A5-%E8%BD%AC%E6%8D%A2-%E5%8D%87%E7%BA%A7-%E7%9A%84%E9%97%AD%E7%8E%AF%E6%95%88%E5%BA%94%EF%BC%8C%E5%88%9B%E9%80%A0%E6%80%A7%E6%80%9D%E7%BB%B4%E5%92%8C%E6%B3%A8%E6%84%8F%E5%8A%9B%E7%AE%A1%E7%90%86/"/>
    <url>/2025/03/01/%E8%AE%A4%E7%9F%A5-%E8%BD%AC%E6%8D%A2-%E5%8D%87%E7%BA%A7-%E7%9A%84%E9%97%AD%E7%8E%AF%E6%95%88%E5%BA%94%EF%BC%8C%E5%88%9B%E9%80%A0%E6%80%A7%E6%80%9D%E7%BB%B4%E5%92%8C%E6%B3%A8%E6%84%8F%E5%8A%9B%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>创造性的思维来源于多年的思考积累，而从事创意工作（比如文案策划、设计等职业，或写作）最难的部分之一就是：简单的解释自己。</p><p>从表面看 随机性&#x2F;创造性 的 工作可能看起来懒惰且无规律，You write. You walk. You travel. You order a latte, then a Diet Coke. 或者你看的书都是比较随机的，甚至你都在期待随便找一个人聊天就能擦出火花。</p><p>就是在浪费时间，因为论为创意性质的工作本质就是这样，外表看起来很悠闲，但内心却很痛苦。</p><p>寻找创意灵感，根本就没有一个方法甚至是一个开关。它是一项全天候、无休止的工作。这是一种幸福，同时也是一种折磨。</p><p>加班是强制性的，但报酬是投机性的。</p><p>别人周六晚上出去吃饭放松，而你却要扫视菜单上的字体设计，摸摸椅子的绒面质地寻找灵感。餐盘的嘈杂声让你抓狂。天花板上没有隔音板也让你抓狂。紧接着，你就会陷入沉思，为自己将来要开的餐厅设计一个氛围板，而你的约会对象则希望他们在别人身上刷了右键。</p><p>虽然顿悟是一瞬间的事，但种子却是在多年的 观察&#x2F;训练 和沉思&#x2F;思考 中播下的，而学会观察（注意力分配）则是底层基础。</p><p>我在《长期主义》系列中也均提到过，只有底层认知的转换&#x2F;升级 ，才能真正做到思维的改变。</p><p>而认知 转换&#x2F;升级的闭环（一个过程&#x2F;流程），尤为重要。我暂且称为：「认知升级闭环」</p><p>一如既往的举例环节，以【投资】为例：</p><p>👨‍🌾 投资最重要的其实两件事，认知和心力。认知是你对世界本质的洞察，心力是基于洞察做决策并能坚持这种决策。只要尝过一次甜头，就会更加相信，并且会投入更多精力研究，也会投入更多资金。所以说，投资，尤其是长期投资这件事，是「认知升级闭环」的最典型案例。</p><p>那么为什么大多数人会认为投资这件事不靠谱呢？或许很多人太忙，没有时间阅读、思考，但这不是问题的关键！！！</p><p>按照互联网思维的说法，思考，尤其是深度思考，是短期ROI极低，长期ROI极高的事情。</p><p>为什么认知升级很难？因为升级认知在一定节点之前，是一个投入巨大，但收益接近于零的事情。认知升级的效果只会在一个节点之后体现，但大多数人等不到这一天。</p><p>当你无法持续从提升认知中获益时，那么偶然投资于认知提升，就是一个ROI很低甚至是负数的选择。这是一个很现实且可怕的认知，它解释了在对待认知这件事上，人和人为什么会产生极大的差异。也解释了为什么个体认知会产生类似于马太效应的规律。</p><p>我们太容易急于看到努力的结果，是陷于短期忙碌陷阱的一个心理因素。如果把努力分为三种，第一种努力，效果一周见效；第二种努力，效果半年后见效；第三种努力，效果三年后见效。你会如何选？我相信那么大多数人习惯性地把每天的时间花在第一种努力上，这就是陷阱。</p><p>事实也如此，就如同现在多数人都喜欢抖快红的速食垃圾，甚至还讨论出来“方法论”？</p><p>如此“高效的忙碌”是一件很刺激、很上瘾的事情，但这是不对的。</p><p>或许，很多人还没有意识到。</p><p>再次举例：如果10场面试，每场1小时，很容易上瘾。但更好的做法是花3小时研究如何更有效地面试，然后每场面试控制在30分钟内。这样只需要花8小时就可以高效完成，并且这种效果在后面所有的面试中依然发挥作用。</p><p>这个道理很容易讲通，但我们依然习惯于忙于每场1小时的面试，因为习惯于用过去的节奏忙碌是一件成瘾的事情。</p><p>其实这个例子就 说明&#x2F;分析&#x2F;解释 了为什么大多数人愿意付出一切辛劳却躲避思考的行为。</p><p>其实回到每天的时间分配上，如果承认「10000小时定律」，就必须承认「注意力是战略资源」。所以人和人之间的差别不在于先天的智力体力，而在于「注意力的分配」。</p><p>如果我们能把上面提到的「三种努力」（短期见效、中期见效、长期见效）合理地安排在每一天，而不是每天沉迷于短期见效的努力，那么我们就能进入正向的循环 —— 一种能从认知升级中受益的循环。</p><blockquote><p>比如，冥想&#x2F;正念 10分钟后工作30分钟的效果，远比忙碌60分钟效果好。而冥想&#x2F;正念 这10分钟的过程就是解决「注意力分配」的问题。</p></blockquote><p>而要想彻底解决「注意力分配」，找到使命、设立目标、建立反馈闭环，就成为必要条件。所以人和人最终的差别，就在于「注意力分配系统」的差别。</p><p>所以，你会怎么办呢？如何做呢？</p><p>如果在意自己的人生结果，就要在意「注意力管理」。因为，注意力投在哪里，时间就投在哪里，时间投在哪里，会决定我们成为怎样的人。</p>]]></content>
    
    
    <categories>
      
      <category>Life Co., Ltd.</category>
      
    </categories>
    
    
    <tags>
      
      <tag>life</tag>
      
      <tag>think</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>我们是如何浪费认知资源的？</title>
    <link href="/2025/02/28/%E6%88%91%E4%BB%AC%E6%98%AF%E5%A6%82%E4%BD%95%E6%B5%AA%E8%B4%B9%E8%AE%A4%E7%9F%A5%E8%B5%84%E6%BA%90%E7%9A%84%EF%BC%9F/"/>
    <url>/2025/02/28/%E6%88%91%E4%BB%AC%E6%98%AF%E5%A6%82%E4%BD%95%E6%B5%AA%E8%B4%B9%E8%AE%A4%E7%9F%A5%E8%B5%84%E6%BA%90%E7%9A%84%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<p>一、认知资源和认知负荷的定义</p><p>简单来说，我们的大脑容易无聊，无时无刻都要靠视觉、听觉来输入信息，一旦缺乏信息，就像食物的小动物一样，四处寻找可以获取信息的东西。比如：当代流行的抖快红速食信息套餐、甚至在90年代中流行的“厕所读物”（报纸&#x2F;杂志）。</p><p>这种“喂投式内容”并非一件好事，比如使用电子产品过长，会使大脑灰质密度（处理信息效率部分）下降；另外，长期使用社交媒体，会减少海马体活动，记忆力和注意力下降，导致大脑出现进入「<strong>认知负荷</strong>」。</p><p>从心理学角度来讲，目前「认知负荷」还属于多维概念。从各种文献的角度来看，是指：作业人员信息处理能力和认知资源的比例，是否满足实际需要；以及，看做满足期望绩效所需，信息处理能力与可用处理能力之间的差异。</p><p>当然还有不同学者的看法，比如：多重资源模型理论（Multiple Resource Theory，MRT）提出者；其认为工作量与任务、资源有一定关系，负荷反映着所执行任务时产生的心理压力；还有工作环境与外部环境带来的认知负荷不同；前者会给后者带来“精神负荷”；一个人付出相当大脑力活动，信息处理效率会延迟，当信息处理超过所需容量，人的精神压力会接憧而至。</p><p>或者你会绕进去？其实简单理解就是：「认知负荷」涉及到日常 生活&#x2F;工作 中任务要求、时间压力、个人能力、以及绩效、努力程度，大脑处理问题效率等多个因素所形成。</p><p>再简单一点的理解就是：认知跟体力类似，如果过度使用它，会出现疲劳，当大脑表面工作超过整体运行占比时，脑力、心里等多方面不适的信号就会出现。导致你疲倦、心神不定等等，甚至产生错误的判断&#x2F;决策等。</p><p>👨‍🌾所以，信息处理决策越多，人越乏力，最后大多决策不但非理性，还容易出现错误。</p><blockquote><p>所以我为什么总是提倡PIM（信息处理）很重要，不论是生活中的点点滴滴、工作中的项目流程以及学习新知等等。</p></blockquote><p>那我们是如何浪费认知资源的呢？</p><p>根本来说，就是「选择」。</p><blockquote><p>就如老话所讲：“<strong>选择大于努力</strong>”。方向不对、细节不控制、核心没抓住，在过多努力无用。</p></blockquote><p>你可以把「<strong>认知资源</strong>」想象成一盆水池子，每天通过饮食、休息为它储备能量，进而，再把能量用在能够最大化创造价值的事情中（储备和消耗在一个池子中）。如果，每天为一些不重要的事情，消耗大量资源，我们在思考或解决问题时，就会出现认知不足的情况；同样，如果白天做大量损耗资源的事，如果晚上需要做一些临时性决策，往往会，极为敷衍了事。</p><p>👨‍🌾 经典举例环境来了，大致这些问题可以分为两类。</p><h3 id="【生活】"><a href="#【生活】" class="headerlink" title="【生活】"></a>【生活】</h3><ol><li>很多人早晨起床第一眼就要看手机，刷牙时还要看短视频，任何情况下都要一心二用，坐地铁、打车路上边听歌、边刷朋友圈信息流，什么都记不住，还把脑袋搞的乱七八糟。</li><li>很多女生出去玩，常常因为化妆或穿衣打扮，白白浪费掉1-2个小时的时间，最后不但自己不满意，还会因迟到引发各种小事，造成一天玩乐都没心情。</li><li>生活不规律导致“忘性”大，很多东西经常不知道跑哪里了，比如经常找不到“指甲剪、挖耳勺”这些小东西。而有些比较容易较真的人，越找不到越想找，最后根本没时间做其他事情。</li></ol><h3 id="【工作】"><a href="#【工作】" class="headerlink" title="【工作】"></a>【工作】</h3><ol><li>经常开会中“愣住了”（走神），一分钟后又回到正轨。仔细问后却说：今天中午吃什么？</li><li>电脑、手机上笔记的工具不下6-7个，常常因为用哪个软件而纠结；各种效率软件加持，最后加持在“选择”当中，把时间花在这些无效的事情上。</li><li>总想搞清楚有些东西到底是怎么 玩&#x2F;做 的，于是花费大量时间自我摸索，也不去请教别人，最后不但没搞定，还浪费不少时间。</li></ol><p>👨‍🌾当然这些都是随便举的例子，其实还有很多，它们均属于比较消耗「认知资源」，令大脑进入负荷状态；不妨回想下，从早起醒来到晚上睡觉之前，都做过哪些事情，这些重要吗？</p><p>或者，是不是我们大脑忙于思考很多并不重要的事，而浪费掉大量认知资源；亦或，大脑总想着重要的事情，到节骨眼，又束手无策了？这些事都容易让一天效率低下，最终，3-5件事都没干成，反而认知资源却被消耗光了。</p><p>有些同志又会说了：这些不是很简单吗？我控制下、整理好习惯不就得了？</p><p>请问：你真的了解控制吗？为什么很多人的控制，最终走向了放弃？换个维度，为什么道理我都懂，但是我做不好？天天学习「方法论」最后自己落到实际载体上样样不行？</p><p>👨‍🌾 其实，<strong>自我控制</strong>也叫认知及控制（cognitive control），是人的执行功能。是选择某个目标，控制思想和行动，以达到目标与心理一致，也称之为“ 结果导向行为”。</p><blockquote><p>这也是我一直提倡要“结果论”，而并非“目标论”。自己立的flag还少么？有多少做到的呢？</p></blockquote><p>在「<strong>自我控制</strong>」的过程中，我们会基于自我价值、判断目标做出一系列计划，这些计划基于经验，又要适应无法预见的变化，还要监督行动，并抑制偏离目标的习惯反应以保持目标，并把结果作为目的。</p><p>所以「<strong>自我控制</strong>」涉及六个方面：</p><ol><li>心理导向的决策（选择目标）</li><li>工作记忆（记住目标）</li><li>目标规划（分解目标）</li><li>自上而下注意（专注目标相关的事情）</li><li>元认知（监控自己的行为是否朝着目标走）</li><li>追求结果</li></ol><p>你们看，「<strong>自我控制</strong>」并非仅靠单一「意志力」心理活动，而是一个追求结果的流程。</p><p>而大多数人又是如何做的呢？</p><ol><li><p>看到自己体重上涨时，心中会暗暗发誓，”哎呀，不行了，我真的要减肥，从明天开始坚决不吃碳水化合物”。坚持1天、几天、1个月、几个月后慢慢倦怠放松，不维护、不科学锻炼，导致反反复复的失败。面对美食诱惑、没有稳定的正反馈，就会再次回到以往的状态。</p></li><li><p>看他人写的多，也想写。从明天开始使劲的AII-IN，如同写文章，日更，坚持打卡，这些行为，当存在不可抗拒的原因时（比如没话题、没写的动力及各种理由），几天后能量被耗尽，再次失败。</p></li></ol><p>👨‍🌾 所以，「<strong>报复性松懈与控制</strong>」的模式，是很多人问题的本质根源。或者说，大脑本身是矛盾体，每天要处理很多问题，这部分想这样，那部分想那样，我们表露在外面的只有一种情况，它们在心中必然会打架，会有一方胜出。</p><blockquote><p>书到用时方恨少，事非经过不知难。当大脑两部分、谁也无法说服谁时，自我会陷入“六神无主”境地中；一旦势均力敌、负面行为压倒正向想法，你会不会很纠结？损耗巨大精力不说，还会恨铁不成钢，认为“自己真没用，连这点小事情都管不住自己”。</p></blockquote><p>所以，你会怎么办呢？如何控制呢？</p><p>当然「认知资源」属于具备动态变化属性及再生资源属性，一定范围内，你想<strong>自我控制</strong>，绝对能够做到；超过范围后，越控制越无法控制，反而进入内耗状态。它有点像阀门，边界内，<strong>自我控制</strong>资源会越用越聪明，历经扩容后，逐渐走向正反馈，如果长期搁置不用，它也可能没有变化，甚至出现退化的可能。</p><p>所以，失败的<strong>自我控制</strong>者对成事、动机、健康和幸福都会产生负面影响；而成功的<strong>自我控制</strong>者，根本不会大脑进入“认知负荷”状态。‍这就延伸出一个最重要的问题：到底是<strong>自我控制</strong>却强，以后越容易控制，还是「越控制越容易放弃」？中间阈值到底该如何掌握？</p><p>这里又有一个理论刚好适用，那就是：<strong>有限自制力理论（The finite principle of self-control）</strong></p><p>简单来讲，自制力是一种控制和约束自己情绪的能力，我们的自制力就像肌肉的力量，存在上限，当超过这个上限，即便大脑强迫出的各种想要做的行为，自己的控制行为都会下降。</p><p>举例环节：尽管，你知道每天刷手机的行为已经让自己“疲惫不堪”，不想玩，要去控制，但过一段时间后，仍然会再次拿起手机。</p><p>这种行为叫什么？这种行为，心理学家认为就是「<strong>自我控制衰竭</strong>」。有关<strong>自我控制衰竭</strong>的解释，大概分为两种：</p><blockquote><p>「<strong>自我控制衰竭</strong>」和疲劳存在共同特征，当身体疲劳或出现葡萄糖降低时，耐心就会下降。</p></blockquote><h3 id="第一种，【能量耗竭】"><a href="#第一种，【能量耗竭】" class="headerlink" title="第一种，【能量耗竭】"></a>第一种，【能量耗竭】</h3><p>在<strong>自我控制</strong>时，开始阶段会出现大量能耗，控制资源的储备也会随之下降，当控制下降到一定程度，就会出现衰竭状态；一旦衰竭，自己就没有足够的资源，来支撑其完成随后的任务。</p><p>这种耗竭有点像生活常识，如，一个家庭中，通过各种途径储蓄了一定的金钱，当你第一阶段消费大量金钱后，就不会有足够金钱，来支撑紧随而至的第二阶段消费。</p><h3 id="第二种，【能量保存】"><a href="#第二种，【能量保存】" class="headerlink" title="第二种，【能量保存】"></a>第二种，【能量保存】</h3><p>最初面对任务，<strong>自我控制</strong>并未达到耗尽“控制资源”的程度，但这种资源损耗，会刺激自己自动产生，并保存剩余的控制资源的意识；就像长跑运动员，半路疲惫时，有意识保存体力，然后，以备不时只需所用。</p><p>该方面，心理学家曾做过一个很巧妙的实验，大概如下：</p><p>被试者分为两组，表面要进行两项不同的“<strong>自我控制</strong>任务”，在第二项任务开始前，实验组告知A组被试者，还有第三项任务等着他们，B组则没有第三项任务。结果发现，A组进行第二个“<strong>自我控制</strong>任务时”，比B组表现要弱一些。</p><p>意味着什么？</p><p>同志们可能为后面更重要的事，保存一定的“实力”（<strong>自我控制</strong>资源）资源。然而，为了进一步验证该实验的准确性，研究者又在另一项实验中，按照“能量耗竭”的观点，提出验证。</p><p>结果发现，动机水平不同，导致随后表现均出现差异。</p><p>尽管被试者提前完成“<strong>自我控制</strong>任务”，若告知，后续临时加的任务，能得到更多报酬，他们仍然会做出良好的表现；反之，如果告诉他们后续有任务，奖励不是太大，且必须完成，大家重视程度则会降低。</p><p>👨‍🌾这TM说明什么呢？人在面临不同任务，会选择性分配控制资源。当一项任务完成，临时再加一项任务，动力可能会减弱，如果持续进行下去，会出现「认知负荷」。</p><p>如果下一项任务，得到报酬（奖赏激励）比较高，你可能会铆足劲，再次把认知资源拉高，以保证完成，完成后，<strong>自我控制</strong>资源，就会进入衰竭状态。</p><blockquote><p>如果一个人在前一天出现暴饮暴食、大量吸烟、熏酒、熬夜行为，第二天葡萄糖水平会降低，<strong>自我控制</strong>资源也会下降，陷入低效状态，这种低效，还会随着不正当的循环进而加剧变化。</p></blockquote><p>所以，不遵循身体固有规律，一鼓作气想做成某事，必然走向“失败控制者”的队列；把事情做到能量耗竭之前，恢复后再进行，是“成功控制”者必备状态之一。</p><p>如果出于某种目的，故意克服当前情绪状态，用另一种情绪状态取而代之，无论是抑制还是夸大，都有可能导致<strong>自我控制</strong>资源的下降。其次，相对自由表达自我想法，抑制思想，需要消耗更多意志力，因为思想有一种天生特性，常常会返回想摆脱的事物中去，这被称为逆效应（ironic effects）。</p><p>而这个实验，更说明一些隐形层面的状态都会损耗“控制资源”，那就是：情绪调节、思想抑制、抵制诱惑、分心控制。</p><p>比如「分心控制」常常消耗的是“注意控制”，比如边看手机，边听歌、边吃饭行为，算分心吗？边听歌&#x2F;白噪音、边写文章算分心吗？</p><p>准确来说，算。</p><p>毕竟，它更像一种干扰任务，看似较轻，实则在做重要任务时，你才会发现，它已经消耗你巨大控制资源。</p><p>另外，当你放弃某个目标时，也会消耗控制资源，看似不在进行，但致力该目标过程中形成的记忆现象，依然存在。这就像，我们经常使用的浏览器，你以为关闭网页，电脑就不在卡了吗？</p><blockquote><p>当然，如果你是“成功控制”者，已经<strong>自我控制</strong>良好的情况下。「分心控制」是可调控的，并且是1+1&gt;2的。</p></blockquote><p>不是的，缓存也需要清理。</p><p>你可能会说，我没有太刻意，为什么还会消耗「控制资源」呢？要知道，控制资源有显性与隐性，显性是看得见的行为，隐性是早已经形成的坏习惯，尽管不用控制，可它仍在消耗。</p><p>看到这里，现在应该能清晰认知到，一天虽然事情没做多少，大脑为什么会出现负荷状态了吧？那就是：很多隐形部分，是显像层面无法看到的，而你在时时刻刻无形的消耗。</p><p>二、如何保护认知资源？</p><p>例如我乔（乔布斯），出现在大众视野中常年保持一个简单打扮，除公共传播以外的考虑，更多是个人风格。</p><p>大佬每天穿着大致极简的衣服，目的不是为了「不在衣着选择上花费精力」，这看起来有些难以理解。穿衣服需要花费精力吗？实际上，他们的穿衣习惯是对自己「认知资源控制」态度的一种体现。</p><p>对普通人来说，穿什么、吃什么是非常必要的选择，对于大佬们而言，这些选择会占用认知控制资源。更加划算的选择是：将更多的认知资源投入到产出更高的事情中。</p><p>我把这叫做“认知资源弃子”。</p><blockquote><p>弃子，围棋术语。指故意放弃一些棋子，以换取更大好处，这个好处往往是非可量化，要从整体大局通盘考虑，也就是说，明面上放弃一些东西，但整体更有效率，更有利。</p></blockquote><p>从另一个维度解读，关键只有一条，你不需要去做很多选择的事情，试着让一切变成「良好习惯」，才会降低自己认知资源的消耗、与控制力。</p><p>比如以前用完的挖耳勺、指甲刀必会到处乱丢，经过各种找不到的教训后，才会把它固定放到一个位置，这种下意识，不需要耗费更多「控制资源」的行为恰巧最关键。</p><p>诚然，这与思考指甲剪、挖耳勺应该放在哪，我要用完放回去等一系列思维相比，后者就是我的「认知资源弃子」；你的固定习惯、每天吃什么、如何打发时间，这些被视为安全感的东西，会为你减少控制资源。</p><p>所以超越了意志力，就是形成习惯。</p><p>减少「认知负荷」，保护「认知资源」的最佳策略，并非取决于，处理多少事（或同时处理多少事）；而取决于，事情实施的容易度，以及，能量即将耗尽时，是否给自己留出足够多的休息时间，让它恢复。再加上《一万小时定律》，终会有所成。别说一万小时，一千小时后，你已经比当初的“你”牛逼多了。</p>]]></content>
    
    
    <categories>
      
      <category>Life Co., Ltd.</category>
      
    </categories>
    
    
    <tags>
      
      <tag>life</tag>
      
      <tag>think</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>自我知觉很重要，你知道什么，不如你如何思考</title>
    <link href="/2025/02/28/%E8%87%AA%E6%88%91%E7%9F%A5%E8%A7%89%E5%BE%88%E9%87%8D%E8%A6%81%EF%BC%8C%E4%BD%A0%E7%9F%A5%E9%81%93%E4%BB%80%E4%B9%88%EF%BC%8C%E4%B8%8D%E5%A6%82%E4%BD%A0%E5%A6%82%E4%BD%95%E6%80%9D%E8%80%83/"/>
    <url>/2025/02/28/%E8%87%AA%E6%88%91%E7%9F%A5%E8%A7%89%E5%BE%88%E9%87%8D%E8%A6%81%EF%BC%8C%E4%BD%A0%E7%9F%A5%E9%81%93%E4%BB%80%E4%B9%88%EF%BC%8C%E4%B8%8D%E5%A6%82%E4%BD%A0%E5%A6%82%E4%BD%95%E6%80%9D%E8%80%83/</url>
    
    <content type="html"><![CDATA[<p> 如果你不能「不断的与自己错误的直觉做斗争」，那就说明：</p><h3 id="【第一层】认知问题"><a href="#【第一层】认知问题" class="headerlink" title="【第一层】认知问题"></a>【第一层】认知问题</h3><p>学识、知识、底层&#x2F;基础 的东西不够，甚至说没有「自我觉察」（想做的事情太多，而时间太少做的太少）。所以导致了无法主动「知觉」。</p><p>你的偏好和认知，在不同的情境下做出行为决策，而行为决策的结果最终也反过来修正主观的偏好和认知。</p><p>你没有这个过程，怎么可能会「知觉」？你只有通过不断的深入思考，扩大知识面，多实践，才能够让我们意识到错误性，从而让预测趋于客观。</p><p>比如：当负面情绪产生的时候，也正是最好的观察自己的时机。最有用的方法还是向自己的内心探寻。过去这段时间里，通过自己觉察，意识到了自己内心更多深层次的需求。</p><p>这同样是一种「自我觉察」，要学会这种模式并举一反三。</p><p>当然，这个也就是「知行合一」的主旨。</p><h3 id="【第二层】思维问题"><a href="#【第二层】思维问题" class="headerlink" title="【第二层】思维问题"></a>【第二层】思维问题</h3><p>「经历带来感受，感受形成知识，知识决定行为，行为决定思维」，同样也是一个过程。思维的改变感受来源于经历、阅历。</p><p>「在任何思维理解之前，先要有表达；在任何表达之前，先要有关于重要性的感受」</p><p>所以很多行为科学学科，心理学、经济学，讲的东西都很相似，而是否在跨学科之间找到联系，是非常大的乐趣。</p><p>同样也考究你的学识、你的认知及你的思变&#x2F;「证实思想」（justificationism）。</p><p>如果你在【第一层】都实现不了，基本上你也不会到【第二层】</p><h3 id="【第三层】你猜？"><a href="#【第三层】你猜？" class="headerlink" title="【第三层】你猜？"></a>【第三层】你猜？</h3><p>为什么是你猜？当你完成完善了前两层，很多事情（职场&#x2F;生活）都会豁然开朗，一通百通。</p><p>这些都属于我们内化了的「隐性知识」，需要持续不断的学习、坚持等等行为来构建。</p><p>若我们一直停留在自己的舒适圈内，没有知识体系、经验体系的迭代，便会愈发「固执己见」，独立思考也无从谈起。此间增长的偏见，不仅会幻化出一种「世人皆醉我独醒」的错觉，还会消磨掉我们的理智与情感。</p><p>我们锻炼独立思考的能力时，拓展着自己的边界，不断将自己的知识体系、经验体系交织，智慧也在不断增长。当我们像苏格拉底所说「I know nothing except the fact of my ignorance」的时候，自然而然地从内心升起谦卑，「心、佛、众生三无差别」。</p><p>佛学中所谓「<strong>悲智双运</strong>」便是如此。</p><p>无论是独立思考，还是 跨界&#x2F;学科 学习，都是要让我们放下我执，以慈悲和智慧提升自身素质、和谐自他关系。</p><p>我们的视野不能仅仅停留在自己的兴趣领域，博采众长是现如今的一个关键技能。用佛教思维来看，一即一切，一切即一；一切众生语言陀罗尼，这些都是一切事物的共同逻辑模型而已，适当的跨界学习和拓展自身边界是有好处的。</p><p>通常，我们总是依据自己的知识经验体系去看待世界，这就是偏见、分别；世界并不只有自己的知识经验体系。一旦落入偏见，就很难换位思考，而是陷入自己给自己设置的陷阱中，忘记自己只是芸芸众生的一个小小的组成部分而已。偏见即是分别，分别就没了慈悲与平等。</p><p>如果可以跨越我们自身的边界，向外界学习并寻求多元素交叉，不仅可以拓展眼界、激发灵感、挖掘潜力、提升能力，还可能探索出创新性的问题解决方案，锻炼我们独立思考的能力，同时也能培养我们的慈悲心、平等心。</p><p>所以保持理性、中性、客观的态度，以旁观者的视角来研究包括社会、组织&#x2F;团队、个人等在内的各种问题，是具备独立思考的前提，也是「独立之精神、自由之思想」的基础。</p><p>这跟你在哪个国家、哪个组织&#x2F;团队无关，有关的只有你自己。</p><p>这三层很重要，是因为它们决定了我们是否能真正的进步。</p><p>如果我们把不正确的东西误以为正确，不论吃再多的盐、读再多的书、获得再高的学位、赚再多的钱，也只能在原地踏步甚至倒退，而自己还有种「懂很多的错觉」。</p><p>什么样的认知、什么样的思维不仅影响个体，还影响群体。</p><p>在 2019 年 Berkshire Hathaway 的股东大会后，有记者对 Charlie Munger（查理·芒格）表达了一个困惑：“大会里的很多内容都是常识，为什么还有这么多人为之疯狂？”</p><p>Munger 不假思索地回答：对的，所有的都是常识。不过，当人们用「常识」（commen sense）这个词的时候，他们其实说的是「非常识」（uncommon sense），因为人类的标准状态就是无知和愚蠢」</p><p>所以我们需要保持：</p><ol><li>即使知道了，也要告诉自己不一定正确</li><li>接纳自己的无知，保持好奇心</li><li>你知道什么，不如你如何思考</li></ol><p>👨‍🌾最后，借用天文物理学家 Neil deGrasse Tyson 说过一段话，值得时常提醒自己 ── “<strong>我可以向你保证，决定你生命最重要时刻的，不是你知道些什么，而是你怎么思考。当你遇到从未见过的问题时，你会怎么做？你会不会说「我从来没有受过这方面的训练，然后掉头就走」？还是，「哇！这是我从来都没见过的问题，让我试着解决它。」科学素养不取决于你知道多少，而取决于你的大脑如何思考，如何提问，这能让你去探索外面的知识和信息，以寻求在这个世界里客观真实的东西。</strong>”</p>]]></content>
    
    
    <categories>
      
      <category>Life Co., Ltd.</category>
      
    </categories>
    
    
    <tags>
      
      <tag>life</tag>
      
      <tag>think</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>精神手冲（信息 过度/过剩）让你缺乏基本逻辑，智力肥胖（知识 无检验及特权性）让你甘心被割，新无知时代导致的群体性孤独（mass loneliness）如何破解？</title>
    <link href="/2025/02/28/%E7%B2%BE%E7%A5%9E%E6%89%8B%E5%86%B2%EF%BC%88%E4%BF%A1%E6%81%AF-%E8%BF%87%E5%BA%A6-%E8%BF%87%E5%89%A9%EF%BC%89%E8%AE%A9%E4%BD%A0%E7%BC%BA%E4%B9%8F%E5%9F%BA%E6%9C%AC%E9%80%BB%E8%BE%91%EF%BC%8C%E6%99%BA%E5%8A%9B%E8%82%A5%E8%83%96%EF%BC%88%E7%9F%A5%E8%AF%86-%E6%97%A0%E6%A3%80%E9%AA%8C%E5%8F%8A%E7%89%B9%E6%9D%83%E6%80%A7%EF%BC%89%E8%AE%A9%E4%BD%A0%E7%94%98%E5%BF%83%E8%A2%AB%E5%89%B2%EF%BC%8C%E6%96%B0%E6%97%A0%E7%9F%A5%E6%97%B6%E4%BB%A3%E5%AF%BC%E8%87%B4%E7%9A%84%E7%BE%A4%E4%BD%93%E6%80%A7%E5%AD%A4%E7%8B%AC%EF%BC%88mass-loneliness%EF%BC%89%E5%A6%82%E4%BD%95%E7%A0%B4%E8%A7%A3%EF%BC%9F/"/>
    <url>/2025/02/28/%E7%B2%BE%E7%A5%9E%E6%89%8B%E5%86%B2%EF%BC%88%E4%BF%A1%E6%81%AF-%E8%BF%87%E5%BA%A6-%E8%BF%87%E5%89%A9%EF%BC%89%E8%AE%A9%E4%BD%A0%E7%BC%BA%E4%B9%8F%E5%9F%BA%E6%9C%AC%E9%80%BB%E8%BE%91%EF%BC%8C%E6%99%BA%E5%8A%9B%E8%82%A5%E8%83%96%EF%BC%88%E7%9F%A5%E8%AF%86-%E6%97%A0%E6%A3%80%E9%AA%8C%E5%8F%8A%E7%89%B9%E6%9D%83%E6%80%A7%EF%BC%89%E8%AE%A9%E4%BD%A0%E7%94%98%E5%BF%83%E8%A2%AB%E5%89%B2%EF%BC%8C%E6%96%B0%E6%97%A0%E7%9F%A5%E6%97%B6%E4%BB%A3%E5%AF%BC%E8%87%B4%E7%9A%84%E7%BE%A4%E4%BD%93%E6%80%A7%E5%AD%A4%E7%8B%AC%EF%BC%88mass-loneliness%EF%BC%89%E5%A6%82%E4%BD%95%E7%A0%B4%E8%A7%A3%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<p>精神手冲（信息 过度&#x2F;过剩）让你缺乏基本逻辑，智力肥胖（知识 无检验及特权性）让你甘心被割。</p><p>作为老互联网人，做这么多年，从红利期到现在的废柴期。看过的太多，知道的也不少。虽然我很鄙视「抖快红」这三家，但是那是你吃饭的家伙，我也不好说什么，毕竟这属于「主流营销策略」。但是我也讲过很多次，在职业规划和成长性来说，你操作「抖快红」是没有任何价值的，甚至只是「短线操作」。</p><p>而多数人沦为【观看者】会造成什么呢？</p><p>比如“炫耀”，仿佛整个世界都在跟我比。首先，我的价值观慢慢被他们塑造，开始觉得物质和外在的成就才是王道，真实的、内心的成长和价值似乎变得没那么重要了。然后，我也不禁会拿自己和他们比较，觉得怎么就差那么多呢？这样一来，心里就容易产生不满、焦虑，甚至自卑。为了不输给他们，有时，我可能会买一些自己其实根本买不起的东西，只是为了在社交媒体也能“亮一下”。这不仅会陷入经济压力，还在给社会添一份浮躁和不平等。更重要的是，炫耀文化下，我们看待别人容易变得批判和冷漠。因为，对那些没办法跟上这种“标准”的人，会心生轻视。</p><p>这一切不限于物质成果，还包括情感状况、人际关系或其他非物质的经验。</p><p>比如“成功”，各种知识付费大佬的视频，动不动一个月赚几百万，怎么通过“套路”快速成功。他们也报过课程，学完后，自己并无法达到宣传中的效果，而且还有那些一个标题，配上无关视频二次加工的新闻，更让人无所适从。</p><p>所以，信息爆炸的时代，99%都是演出来的东西，随时发生在身边。</p><p>基础内容还可以判断，深层次却防不胜防，然而，这种现象，到底如何产生的呢？我们如何隔绝呢？</p><p>一、知识的权利</p><p>知识是一种权利，人类知识创造依靠什么？那些一线上努力的科研人员、思考人生的哲学家、各种发明创造的人。他们像“知识工厂”第一个生产线，大家期望很高，认为总是追求事实和真理，只有他们提供正确和有益的知识，这个社会才能不断向前发展。</p><p>可提出的理论、观点对社会产生的效用通常不是直接的、明显的；他们的思想可能需要经过一系列的过程、时间和验证后，才能真正对社会产生可见的、具体的影响。</p><blockquote><p>👨‍🌾这点犹如PKM的各种方法论一样，与刚上两篇提到的减法、专注、复盘一样。</p></blockquote><p>一些知识分子提出不太靠谱的主意，可能会给社会添堵。他们提出了问题方法，自己反而没事，反倒是那些真心实践这些理念的人，要吃这个哑巴亏。</p><p>这种情况下，知识分子好像有了一个“可以随便搞，不用负责”的金卡。比如：速成课程培训。在国内存在各种“速成、培训课程或证书”，声称短时间内，可以提供专业技能等等。</p><p>这些会造成什么呢？那就是智力肥胖（ #IntellectualObesity ），盲目且盲从相信一些知识分子、甚至是一些所谓的“知识”。</p><p>二、算法垄断信息</p><p>互联网时代创造了满足需求的算法，更加垄断了信息。Francis Bacon曾经说：“知识即权利，掌握知识，能给人带来无形的力量”。</p><p>如果从传播学角度看，知识获取并不平等，那么掌握知识传播渠道的人，才真正有用权利。</p><p>比如西方，教堂是唯一能给人解释《圣经》的地方，有了古登堡的印刷机，情况才发生变化。没有互联网时，新闻公司掌握发新闻的权利，现在互联网打破这个局面，每个人都可以说出自己的想法，大家获取信息的方式变得更加全面了。</p><p>可实际上，互联网并不像期望的那样完美。虽然，我们以为互联网会带来更多的民主和自由，但现实是，大公司的参与，让互联网变得更像一个掩盖事实、压制自由的地方，最重要有三个特征：</p><ol><li>数字特权</li></ol><p>互联网早期希望它能成为一个让信息自由流动的平台，随着时间发展，特定大公司和资本开始逐渐掌控这片领域，它们占据了大量的数据，变成了数据界的新“贵族”。然后，大型平台上，哪些信息被优先展示，往往取决于谁给的钱多。这种“付费上位”的模式导致了真实、有价值的信息被埋没。而那些可能夸张或不真实的内容却霸占了前排，更为严重的是，有些数据为了满足某些 人&#x2F;机构 的需要，被故意“美化”或篡改。</p><ol start="2"><li>每个人都是记者</li></ol><p>几乎每个人都可以发声，这无疑是一个双刃剑。这意味着人们可以自由表达意见，但也带来了大量的假消息和谣言。很多内容创作者，尤其是只追求流量和点击的，往往选择制造和传播那些容易引发关注和争议的内容，即使它们并不真实。</p><ol start="3"><li>人人爱吃快餐</li></ol><p>事实上，互联网上很多“知识”都是没经过检验的，就像乱七八糟的消息。要从这些消息中找出真正有用的知识，就像在树林里找鱼，太难了；真正有深度的文章和书，大多都在要收费的网站里，很多人都不愿意掏钱去读。导致了更喜欢简单快速的“快餐文化”。</p><p>这就导致了让多数人的思考变得很浅，很多东西都看不明白了。直白点，我们不害怕新技术出现，我们真正害怕，这些技术把人变得肤浅，或者把你当作数字、代码、像机器里的小零件一样对待。</p><p>但实际上，多数人（观看者）已经是这些小零件了，人人是记者、人人爱快餐，天天「 精神手冲 」让你脑内的信息 过度&#x2F;过剩。</p><p>三、时时刻刻被割的韭菜</p><p>大多数人被收割，是因为缺乏长期逻辑思维训练。</p><p>信息、知识被封装、碎片化并不可怕，更严重的，很多人根本读不懂逻辑关系，不会用逻辑思考。一些人常常看什么都容易激发情绪，本等的做出生物反应。比如：焦虑、生气、迷失、上瘾、愤怒、打抱不平、幻想、恐惧，阈值改变。为啥现在很多人放弃思考，喜欢随大流或跟着感觉走？</p><p>现代&#x2F;当代 商业知道这一点，他们不是跟你讲道理，而是用各种方法刺激你的情感，这种表现具体到结果上，就是“本能收割”。</p><p>什么意思？大企业、公司、利用个人本能反应，达到自己赚钱，获取权利，影响他人的目的。以广告为例，大部分市场策略都是利用人对美的追求、对食物的渴望、对社交的需求，来制造购买行为，这是什么？这就是我说过两次的「情绪营销」。</p><p>好好思考下：因为本能，你入了多少没必要的东西？改变多少观念？改变了多少行为？</p><p>说白了，现在专家不再敢于说真话，传播信息的人有时会故意扭曲事实，大部分接受者也不爱思考。最终，大家一起共舞，你在演他也在演，他演的如此逼真，「精神手冲」上头后你不爱思考也就信了，最终，大部分人失去了对信息的辨别能力。</p><p>这是一个【新无知时代】，它并没有让人变聪明，还可能让人陷入“群体性孤独”（mass loneliness）中，面对这些危机问题。看似一切变多了，实则一切表面化。</p><p>👨‍🌾商业平台既然无法践行信息过滤责任，那我们可以改变自己啊。那么，从「自我角度」出发有没有一些解决办法呢？</p><ol><li>设定离线时间</li></ol><p>学会离线（Offline），离线并不意味着长期远离数字世界，更多提醒我们，忙碌的生活中，找到短暂的平衡，给自己一段没有数字干扰的时间。这样，可以更好地聆听内心、享受真实的人际交往和体验自然之美。</p><ol start="2"><li>学会动脑</li></ol><p>多去尝试新的事物，给自己增加难度。在难度中反思最近发生的事，调整心态，为即将到来的新一周做好准备。只要你习惯了，不仅身心得到充分的休息，还提高了工作，生活的质量。</p><p>3.改变心智思维</p><p>就是我一直在提倡的「寻找本质」，如果你找不到，你可以尝试「适应本质」。第一，剔除那些过时、无益，有害的事物或观念；第二，在此基础上建立新的秩序和规律。比如：坚持健身、践行健康、学习新技能等等。</p><p>所以，“不适应&#x2F;不习惯”是重塑第一步。你正在努力摆脱那些旧的、不再适合的生活方式和思维模式。它可能表现为不规律的作息、不健康的饮食、依赖外部娱乐，逃避问题出现的思维观念等。</p><p>这些行为、思维无疑在干扰和破坏你的身心健康和平衡。然而，当你有了决心，并勇于尝试新的事物、得到正反馈后，你就已经成功跨越“不适应”的第一阶段。</p><p>接下来，你会进入第二阶段：建立新秩序。这个过程中，你的思维模式、行为习惯都将得到全新的重塑和优化。</p><p>循环下来后，不仅提高了适应力，还为生命质量添砖加瓦，要能长期坚持下，你的内心会更加宁静，并成就“人生有限公司”。</p><p>总体来说，就是：摆脱并回归现实，走出来，去尝试、去体验。少接触数字舆论 场&#x2F;洼地，那些心照不宣的逻辑方式，也会离你更远。</p>]]></content>
    
    
    <categories>
      
      <category>Life Co., Ltd.</category>
      
    </categories>
    
    
    <tags>
      
      <tag>life</tag>
      
      <tag>think</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>有效复盘的4种方法推荐及【复盘原则和误区】</title>
    <link href="/2025/02/28/%E6%9C%89%E6%95%88%E5%A4%8D%E7%9B%98%E7%9A%844%E7%A7%8D%E6%96%B9%E6%B3%95%E6%8E%A8%E8%8D%90%E5%8F%8A%E3%80%90%E5%A4%8D%E7%9B%98%E5%8E%9F%E5%88%99%E5%92%8C%E8%AF%AF%E5%8C%BA%E3%80%91/"/>
    <url>/2025/02/28/%E6%9C%89%E6%95%88%E5%A4%8D%E7%9B%98%E7%9A%844%E7%A7%8D%E6%96%B9%E6%B3%95%E6%8E%A8%E8%8D%90%E5%8F%8A%E3%80%90%E5%A4%8D%E7%9B%98%E5%8E%9F%E5%88%99%E5%92%8C%E8%AF%AF%E5%8C%BA%E3%80%91/</url>
    
    <content type="html"><![CDATA[<p>提到「减法和专注」的关系。我们在来套个皮肤来看看，那就是百折不饶的【复盘】。</p><p>【复盘】这个事情，我也讲过很多次（置顶文件自己找）。方法也介绍几个，其实还有更多的一些方式方法，属于纯粹的「方法论」，有没有效果的前提是在于，你是如何正确的、专注的、持续的、有节奏的、积累的、进阶的在做【复盘】（不论是职场还是生活）这个事情。</p><p>比如：</p><p>【正确且专注的复盘】你会：</p><ol><li>诚实记录，不自欺</li><li>每日复盘，做好记录</li><li>不纠结过去，努力创造未来</li><li>深度思考-&gt;复制成功经验，找问题根源</li><li>更关注自我可控制和影响的部分，强调主观能动性</li><li>实践复盘所得，形成正向</li><li>积极面对，不否定自己，持续迭代</li></ol><p>【错误且不专注的复盘】你会：</p><ol><li>自我安慰式记录，打卡</li><li>一周后再复盘，记不清</li><li>努力却看不到成果，焦虑</li><li>陷入自我感动式努力</li><li>强调客观原因，忽略主观原因</li><li>复盘完扔采用旧习惯</li><li>易放弃，得过且过</li></ol><p>👨‍🌾你看，是不是“你”呢？你属于哪一种呢？</p><p>诸多的「方法论」没有一个是适合你的，因为最适合的「方法论」均出自于你的总结、自我的总结，根据 他人&#x2F;前人 的结果并结合【自身的实战经验】组合而成的，而不是你出自你不停的去研究这些方法论。</p><p>那么还有几组方法论也不错，比如：</p><p>一、KISS复盘法</p><p>属于【项目复盘方法】，用于促进下一次活动更好的展开，常被应用于活动策划落地执行或者项目执行结束后总结使用，乙方使用频次会比较多，尤其在给甲方汇报时。</p><ol><li>K (keep) 需要保持的：哪些做得好，以后继续保持。</li><li>I(Improve) 需要改进的：哪些不理想，后续需要改进。</li><li>S (Stop)需要停止的：哪些不利行为，需要停止。</li><li>S (Start)需要开始的：哪些东西缺失，需要开始执行。</li></ol><p>👨‍🌾其实跟OKR也是类似框架，大致的【标准复盘流程】为：</p><ol><li><p>目标回顾<br>目的是什么？目标是什么？计划是什么？</p></li><li><p>结果评估<br>目的是否达到？目标是否完成？有无突发状况？</p></li><li><p>原因分析<br>完成的关键因素？未完成的客观原因？未完成的主观原因？</p></li><li><p>经验总结<br>KISS复盘法</p></li></ol><p>二、PDCA复盘法（戴明环模型）</p><p>这是一种持续改进工具，目前被应用到很多领域，它可以帮助你管理项目，甚至管理人生，让你紧盯目标，不断努力执行的同时，不断检查、复盘、修正，直至成功。</p><p>PDCA是【管理者】的基础工具，国内大厂&#x2F;名厂 如百度、华为、小米等都在用，其实个人和企业、普通员工和管理者都可以用来提升工作效率。</p><ol><li>P(Plan)：计划。确定方针和目标，确定活动计划；</li><li>D (Do)：执行。实地去做，实现计划中的内容；</li><li>C (Check)：检查。总结执行计划的结果，注意效果，找出问题；</li><li>A (Action)：行动。对总结检查的结果进行处理，成功的经验加以肯定并适当推广、标准化；失败的教训加以总结，以免重现，未解决的问题放到下一个PDCA循环。</li></ol><p>三、GRAI复盘法</p><p>这是一个围绕目标，注重结果和目标之间的偏差，从中分析原因并总结规律的复盘方法。</p><ol><li>G (Goal) 回顾目标：当初的目的或期望是什么。</li><li>R (Result)评估结果：和原定目标相比有哪些亮点和不足。</li><li>A(Analysis) 分析原因：事情成功和失败的根本原因，包括主观和客观两方面。</li><li>I (Insight) 总结规律：通过以上的分析找到实物更有效、更符合本质规律的做法。</li></ol><p>四、年月周日复盘法（最笨的方法）</p><p>最笨的方法，最适合什么都不会的“你”。别看沦为最笨，但是最有效且最直观。当你坚持这种“最笨”的方式一年后，你在回头看看，“笨”吗？</p><p>从来没有“笨”的机制&#x2F;方法 ，只有最“笨”的你。</p><p>👨‍🌾最关键的来了，那就是【复盘原则和误区】</p><p>【复盘原则】</p><p>1.目标应遵循SMART原则</p><p>目标必须具备明确性、衡量性、可实现性（可执行性）、相关性、时限性这5个特点，即目标具体可衡量、符合自身的目标&#x2F;目的、具有可执行性的计划且有明确的截止日期。</p><ol start="2"><li>行动过程多记录</li></ol><p>及时复盘（思考或碎片化积累素材），更容易进发新的角度和措施，因为当下的记忆、感受和思考更鲜活。</p><ol start="3"><li>事后及时复盘</li></ol><p>完成阶段目标后，及时复盘。切记过程结束后才集中复盘，久了会淡化事情的经过和当时的思维和情绪。</p><ol start="4"><li>客观复盘</li></ol><p>复盘的时候要不断的问自己「为什么」，深入发掘问题的根本&#x2F;本质 原因。最忌讳停留在问题的表面，造成「无效复盘」。此逻辑与「无效沟通」同理，你说的不再“点”上，浪费自己时间，也会浪费他人时间，甚至对他人造成过多的干扰。被骂别不服气。</p><ol start="5"><li>需要解决的问题</li></ol><p>复盘中找到问题后，一定要找到对应的「解决方案」，并拆解到计划当中。进一步的验证方案的可执行性、有效性。这是复盘的意义。你TM要给出具体的可执行性的方案，放空屁没用。</p><p>【复盘误区】</p><ol><li>复盘没有侧重点</li></ol><p>把近期做过的所有事情都进行无差别复盘，精力和时间消耗较大，以至于后期坚持复盘无动力。这点跟一些PKMer做todo、GDT一样，无情累积、无用项目堆积一起，自以为每个【项目】都重要。还是那句话，最重要最紧急、优先级最高的只能有一个！其他均可简单带过，甚至直接总结经验即可。</p><ol start="2"><li>复盘不分类</li></ol><p>复盘是要进行分类日纳（工作、生活、学习），便于思考的深入和精准，标准不同，角度也不同，思考也会更清晰。很多人无形中也坑在这里，过多的分类标准及无用标签，还TM“中图法”都出来了。</p><ol start="3"><li>只分析不解决</li></ol><p>复盘应更注重行动的改进，要落实和跟进且不断的调整，这才是复盘的意义所在。</p><ol start="4"><li>分析过于笼统</li></ol><p>比如：执行中不够仔细、过于粗心。我TM请问仔细的标准是什么？这都需要事先定好具体的衡量标准，在复盘中通过深入思考，才能找到问题的关键。</p><ol start="5"><li>复盘流于形式</li></ol><p>复盘重点是：思考的过程和后续的改进，切记流于形式。</p><p>👨‍🌾总之，【复盘】是在职场&#x2F;生活 中最有效的方法，没有之一！复盘不仅能磨炼思维（系统思维、框架性思维、创造性思维），提升个人能力（思维管理），更是让他人看见你的绝佳能力（可执行性的解决能力、组织能力、汇报能力、PPT能力等）。</p><p>你就说【复盘】重要不重要吧？还有一些非互联网行业的职业，你很烦日&#x2F;周&#x2F;月&#x2F;季&#x2F;年 报或总结 是吧？【烦】就说明你没认真对待，但凡你认真对待了，你也不是现在的屌样子，你以为这些基础能力不重要吗？这些报和总结 均是“写”的一种，更是锻炼你思维的一种，也是你职场能力的见证（证据）。</p><p>再补充一句，如我工龄20年，为什么不用思维导图或一些图表？因为我脑子里直接就形成了「框架性图谱」，我都直接开始干了，画什么图？这就是精于复盘的一种表现。</p>]]></content>
    
    
    <categories>
      
      <category>Life Co., Ltd.</category>
      
    </categories>
    
    
    <tags>
      
      <tag>life</tag>
      
      <tag>think</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>伪命题的&#39;个人成长&#39;，不如换成&#39;人生有限公司&#39;</title>
    <link href="/2025/02/28/%E4%BC%AA%E5%91%BD%E9%A2%98%E7%9A%84-%E4%B8%AA%E4%BA%BA%E6%88%90%E9%95%BF-%EF%BC%8C%E4%B8%8D%E5%A6%82%E6%8D%A2%E6%88%90-%E4%BA%BA%E7%94%9F%E6%9C%89%E9%99%90%E5%85%AC%E5%8F%B8/"/>
    <url>/2025/02/28/%E4%BC%AA%E5%91%BD%E9%A2%98%E7%9A%84-%E4%B8%AA%E4%BA%BA%E6%88%90%E9%95%BF-%EF%BC%8C%E4%B8%8D%E5%A6%82%E6%8D%A2%E6%88%90-%E4%BA%BA%E7%94%9F%E6%9C%89%E9%99%90%E5%85%AC%E5%8F%B8/</url>
    
    <content type="html"><![CDATA[<p>「<strong><strong>个人成长</strong></strong>」（Personal Development）到底是什么意思？或许很多人以为多增加「<strong>软硬技能</strong>」就是了？多看书多阅读就是了？提高思维认知就是了？</p><p>致命三连问之后我们应该好好思考一下：「<strong>个人成长</strong>」这句话是不是从一开始就错了？</p><p>为什么这样讲？因为这句话会导致很多人以为<strong>个人成长</strong>是通过个人努力、独自修炼达成的，这会走到一个极端。</p><p>这其实是不对的，尤其还在校园的你们，可能会误解的更加极端。</p><p>其实，我们想要成长、尤其是快速地成长，一定要找到一件比你更大的事情（something bigger than yourself），找到比你更大的平台、比你更大的赛道，比你更牛的团队，去解决比你个人问题更大、更难、以及更普遍的问题。</p><p>这样的过程才能带来最快更好的个人进步，且非「成长」。</p><p>我的经验是把所谓的“<strong>个人成长</strong>”换一个更现实、更实在的维度，那就是：「人生有限公司」</p><p>而你，则是这家「人生有限公司」的<strong>创始人&amp;CEO</strong> </p><p>把自己当成一家公司去经营，这样的话可以在「经营管理&#x2F;分析」公司的领域，找到很多可以借鉴的理论，包括管理、财务、战略等方面的理论。</p><p>或许这没什么科学性，还不能被100%数字化。但是因为持续的积累，众多公司和管理者的智慧沉淀，相关内容被实践、被反复验证过，因此其可借鉴的价值要远超过所谓的“<strong>个人成长</strong>”</p><p>比如我有一个习惯坚持了很久，即每当碰到一个人生难题（焦虑、职业天花板、财务危机等等），我都会尝试去解决更为普遍的问题。因为我知道很多人像我一样，会遇到类似的问题。如果我能解决大家的问题，我也能解决我自己的问题。</p><p>也就是说，「当你尝试去解决更多人的问题，你能得到的帮助更多，你能受到的启发更多，你能获得的数据和验证机会更多」</p><p>这个过程中会有两种可能性，第一种是我解决自己的问题，然后把解决的经验和方法技巧分享出去，影响和帮助更多的同志；第二种，从一开始我就试图解决更多人的问题。在解决大家问题的过程中，自己的小问题也被解决了。这两种路径我都实践过，都是有效的路径。</p><p>其「本质思维」是：碰到问题时，我们可以更主动地选择去解决更难、更大、更普遍的问题。这是让自己摆脱困境的最佳机会。</p><p>再举个例子，“有些人”受困于赛道不够大、平台也不够大，所以没有达到自己预期的目标。我在和他沟通时，能明显感觉到在谈及战略问题时，他还是倾向于「单点的思考，缺少系统的视角」。</p><p>而“有些人”在最近几年去了一个更大的赛道，一个发展更快的平台，与一群更牛的人共事、交流、切磋，不知不觉养成了系统性思考的习惯。这些习惯在公司内已经习以为常，直到与公司外的人交流，才会发现鲜明的对比。</p><p>这种最明显的结果就是：可以平等对话了 。过去只能单向吸收其观点，现在有机会在 思维&#x2F;认知 上互相碰撞，彼此都能受益。</p><p>这也是我一直提倡的「有效沟通」！！！</p><p>这种成长是在一个大平台快速前行的过程中，潜移默化积累下来的，效果非常明显。我相信在这个平台上，很多一路同行的伙伴都有类似的感受：感受到自己最近几年的飞速成长。</p><p>对人生而言，最重要的能力就是「做选择的能力」。</p><p>我们能否在人生的每个节点，都能做出相对更为智慧的选择：去选择更大的赛道，更快的平台，与更牛的 人&#x2F;圈子 共事，去解决个人独自无法解决的大难题。如果养成这种选择习惯，我们就会在一次次选择中变得更强，强过任何独自奋斗。</p><p>老话讲：跟对人，走对路。同样也是一个意思。</p><p>忽视所谓的“<strong>个人成长</strong>”，转而去面对更大的问题，选择更大的问题。在解决更大问题的过程中，个人自然有更好更快的成长。到时候，<strong>个人成长</strong>是一个自然而然的结果，而不是一种低效、标准化甚至徒劳的努力。</p>]]></content>
    
    
    <categories>
      
      <category>Life Co., Ltd.</category>
      
    </categories>
    
    
    <tags>
      
      <tag>life</tag>
      
      <tag>think</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>通过《Managing Oneself》的案例式自问自答，引导如何&#39;自我管理&#39;。</title>
    <link href="/2025/02/28/%E9%80%9A%E8%BF%87%E3%80%8AManaging-Oneself%E3%80%8B%E7%9A%84%E6%A1%88%E4%BE%8B%E5%BC%8F%E8%87%AA%E9%97%AE%E8%87%AA%E7%AD%94%EF%BC%8C%E5%BC%95%E5%AF%BC%E5%A6%82%E4%BD%95-%E8%87%AA%E6%88%91%E7%AE%A1%E7%90%86-%E3%80%82/"/>
    <url>/2025/02/28/%E9%80%9A%E8%BF%87%E3%80%8AManaging-Oneself%E3%80%8B%E7%9A%84%E6%A1%88%E4%BE%8B%E5%BC%8F%E8%87%AA%E9%97%AE%E8%87%AA%E7%AD%94%EF%BC%8C%E5%BC%95%E5%AF%BC%E5%A6%82%E4%BD%95-%E8%87%AA%E6%88%91%E7%AE%A1%E7%90%86-%E3%80%82/</url>
    
    <content type="html"><![CDATA[<p>今天在404群组插嘴多说几句，其中提到一个关键词「自我管理」。提到这个词儿，就不得不提彼得·德鲁克的《管理自我（Managing Oneself）》。</p><p>本文首次发表于《哈佛商业评论》1999年3-4月刊，节选自彼得·德鲁克的著作《21世纪的管理挑战》（Management Challenges for the 21st Century，Harper Collins出版社，1999）。本文被称为《哈佛商业评论》创刊以来重印次数最多的文章之一。也是《哈佛商业评论》出版的《自我管理的十大必读》当中的第一篇，同时也是最受欢迎的文章之一。文中彼得·德鲁克提出了七大问题，并自问自答。</p><p>作为自我探索的重要一步，希望各位同志真的花1小时的时间好好作答一下。七个问题也是分不同年纪、甚至是阶段的。建议如下：</p><ol><li>18-25岁回答前5条</li><li>25-40全部回答</li></ol><p>每个人状态、阶段均不同，所以以我为例，作答前五个作为各位的参考。当然全部回答也可以，但是没必要，这玩意我早就做过，我就是纯为了打点字而已，不写点难受。</p><h4 id="一、What-Are-My-Strengths？（我的长处是什么？）"><a href="#一、What-Are-My-Strengths？（我的长处是什么？）" class="headerlink" title="一、What Are My Strengths？（我的长处是什么？）"></a>一、What Are My Strengths？（我的长处是什么？）</h4><p>真正的长处是「<strong>吃喝玩乐</strong>」，并及其专业。因为吃喝玩乐的专业，导致了第二长处就是「扯淡」，正经一点说就是：「布道」。我把布道理解为「因为喜欢和认可而持续推广某种事物的行为」。比如我喜欢“写”，并从中受益，我会持续地推广“写”。我喜欢价值投资，并且从中获得回报，我会坚持推荐价值投资。这也是本频道一直在“写”的真正的长期主义 &#x3D; 「<strong>人生决策</strong>」系统 + 「<strong>价值投资</strong>」系统。</p><p>事实上，在我过去二十多年的职业生涯中，我换过七八家公司，做过十余种不同的工作（职业）和角色，包含零售业销售、金融市场渠道、互联网市场策划、文案策划、互联网运营、品牌策划、公共关系、讲师、产品、组织发展、战略策略、互联网创业等等。看似没有任何关联，但背后始终不变的是我持续地在「布道」。布（规划）自己的道（职业道理），甚至不断在邮件组、公司群体、客户群体持续推荐我所喜欢和认可的事物。因此获得新的工作机会，也因为这种特点而深深爱上了一些工作并赚到了钱。</p><p>所以，扯淡（布道者）是我的身份，扯淡（布道）是我的特长。我所宣扬的，正是我所相信的，也是我所践行的，而且是行之有效、有结果（思维认知&#x2F;金钱），更是我相信他人同样可以从中受益的东西。</p><h4 id="二、How-Do-I-Perform？（我的工作方式是怎样的？）"><a href="#二、How-Do-I-Perform？（我的工作方式是怎样的？）" class="headerlink" title="二、How Do I Perform？（我的工作方式是怎样的？）"></a>二、How Do I Perform？（我的工作方式是怎样的？）</h4><p>我的工作方式很简单，我需要自己探索、实践一些东西，找到我认可的事物，然后向更多人推广，使之被接纳，从自己相信的东西变成大家相信的东西，从最初的想法变成现实中的事物。为了让更多的人相信，我自己首先要相信。为了让更多的人改变，我需要自己先改变。一言以蔽之，我需要知行合一，以行践言。</p><p>我们需要持续的变革，而我认为，推动公司改变、推动部门改变和推动自己改变，究其本质而言是同一件事。而且我们一定要从自己改变开始，推动部门改变，最后推动公司改变。如果我们自己不愿意改变，拿什么去推动他人改变？如果你不改变迟早是最早淘汰的那一个，跟年纪有关系吗？呵呵。</p><h4 id="三、What-Are-My-Values？（我的价值观是什么？）"><a href="#三、What-Are-My-Values？（我的价值观是什么？）" class="headerlink" title="三、What Are My Values？（我的价值观是什么？）"></a>三、What Are My Values？（我的价值观是什么？）</h4><p>频道做了要1年，其实早就反复的说过，那就是：知行合一，即心里想的，嘴上说的，手上做的保持一致。这件事听起来容易，但做起来很难。因为我们一般习惯于「严于律人，宽以待己」，而且我们认为是他人的问题，而不是自己的问题，期待他人改变，而不是自己改变。</p><p>我不是圣人，我也有类似的问题。所以我会用「知行合一」不断去校正自己的行为，我争取做到只做我自己相信的事情，而坚决不做我自己不信的东西。</p><p>「知行合一」不仅是价值观，也是方法论，是我认知迭代的方法论。每当我看到一个认可的方法、理念，我就会去生活工作中践行。而随着践行的深入，我对于这一方法或者理念的认知会更加深刻。“纸上得来终觉浅，绝知此事要躬行”，这句小学就学到的诗句直到现在依然对我们有用。</p><p>「知行合一」也对我选择朋友，选择工作起到了关键的作用，我只会选择那些同样知行合一的人成为我的朋友，所以我真正意义上的朋友很少。我也只会选择那些同样知行合一的公司为我自己的工作环境，我希望能在这个工作环境中坦坦荡荡地做我自己，而不用为了迎合他人而做自己不相信、不愿意做的事情。</p><p>因为持久的「知行合一」，我有能力、有决策的判断任何事物，所以在职场上，多数都在我在操这些职场老白兔们。大家根本就不在一个段位，跟我玩，就两个选择：一死、二如何死。</p><p>这就是我「知行合一」的结果。</p><h4 id="四、Where-Do-I-Belong？（我属于何处？）"><a href="#四、Where-Do-I-Belong？（我属于何处？）" class="headerlink" title="四、Where Do I Belong？（我属于何处？）"></a>四、Where Do I Belong？（我属于何处？）</h4><p>我对于公司的「成长性」很在意，因为我不喜欢简单的重复，也不喜欢一眼看到头的工作生活。我希望不断接触更新鲜的东西，不断尝试之前从未尝试过的工作内容，我希望不断刷新自己，不断成长。因此公司的成长性是我非常在意。</p><p>我们大部分人的生命会归于琐碎，不会在这世间留下任何痕迹。如何在注定平凡的宿命中寻找一线生机，其实最好的办法是：find something bigger than yourself，即找到比我们个人更伟大的事业，成为它的一部分。一个人可以走得很快， 但一群人可以走得更远，前提是这群人都有共同的、远大的目标 —— 这是好公司的终极秘密。</p><p>当然，要 达到&#x2F;拥有 这些“底气”，你需要「知行合一和持续成长」，有了阶段性的结果后，才会 达到&#x2F;拥有 这些“底气”。</p><h4 id="五、What-Should-I-Contribute？（我该做出什么贡献？）"><a href="#五、What-Should-I-Contribute？（我该做出什么贡献？）" class="headerlink" title="五、What Should I Contribute？（我该做出什么贡献？）"></a>五、What Should I Contribute？（我该做出什么贡献？）</h4><p>我会扯淡，我能扯淡，而我所能做出的最大贡献，应该是尽可能大范围地深入推荐那些真正值得推广的理念，比如纯扯淡、有思维的扯淡、有道理的扯淡、知行合一的扯淡。直到这些理念也进入更多人的视野，被他们所接纳，逐步开始尝试，最终变成他们的一部分，对他们的人生产生实质意义的改变，正如这些理念在我的人生产生了价值一样。</p><p>所以，决定我扯淡 多少&#x2F;大小 的主要是以下的要素：</p><ol><li>这些理念是否真正有价值，真正的行之有效？</li><li>这些理念对他人的影响能持续多久？</li><li>这些理念能影响多大范围的人？</li><li>这些理念能够在多深的程度上影响这些人？</li></ol><p>事实上，后面三条要素最早出现在2006-2008年左右，那时我还年少且傻逼的工作，尝试着去通过改变自己而获得新生。我在至少一个工作笔记本的第一页写下了如下公式：</p><ol><li><p>个人影响力 &#x3D; 影响多少人 x 影响他们多久 x 影响他们多深</p></li><li><p>公司影响力 &#x3D; 个人影响力x N</p></li><li><p>成就 &#x3D; 个人影响力+公司影响力</p></li></ol><p>👨‍🌾 以上，就是我的回答。同时，也期待看到你们的 「自我&#x2F;真我 回答」。 </p><p>PS.  我一直说，学会“问”很重要，但优先级最高的则是，先学会“问”自己。才能 学会&#x2F;有效 的“问”他人。《德鲁克七问》如下：</p><ol><li>What Are My Strengths？</li><li>How Do I Perform？</li><li>What Are My Values？</li><li>Where Do I Belong？</li><li>What Should I Contribute？</li><li>Responsibility For Relationships</li><li>The Second Half Of Your Life</li></ol>]]></content>
    
    
    <categories>
      
      <category>Life Co., Ltd.</category>
      
    </categories>
    
    
    <tags>
      
      <tag>life</tag>
      
      <tag>think</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>我们到底差在哪里？认知突破的关键点是什么？</title>
    <link href="/2025/02/28/%E6%88%91%E4%BB%AC%E5%88%B0%E5%BA%95%E5%B7%AE%E5%9C%A8%E5%93%AA%E9%87%8C%EF%BC%9F%E8%AE%A4%E7%9F%A5%E7%AA%81%E7%A0%B4%E7%9A%84%E5%85%B3%E9%94%AE%E7%82%B9%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/"/>
    <url>/2025/02/28/%E6%88%91%E4%BB%AC%E5%88%B0%E5%BA%95%E5%B7%AE%E5%9C%A8%E5%93%AA%E9%87%8C%EF%BC%9F%E8%AE%A4%E7%9F%A5%E7%AA%81%E7%A0%B4%E7%9A%84%E5%85%B3%E9%94%AE%E7%82%B9%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<p>我们到底落后哪里？比人差在哪里？是认知？是思维？是能力？有没有关联性？是进阶？是叠加？</p><p>你怎么看？你怎么想？我举例（衔接上条内容）：如果240天后，中国沿海城市以「捕捞养殖」为行业的供应链体系会全崩，为什么？</p><ol><li>我国是全世界「水产出口」量最大的国家，去年（根据《2023年中国渔业统计年鉴》）福建水产出口额为88.5亿美元，占当年全国水产出口总额230.3亿美元的37.1%，以一省之力完成全国水产出口额的三分之一，而且福建还连续10年蝉联全国水产出口额第一大省。</li></ol><p>其次福建是全国最大的鳗鱼养殖加工出口省份，包括我们经常吃的“南美虾”（平时我们说的对虾或白虾），也是全球最大的南美虾消费和进口国。</p><p>核废水到了国内沿海，自己想想？还卖的出去？尤其最近还是开海的，这么多货扔回去？</p><p>内需不敢吃，外面出不去？怎么弄？</p><ol start="2"><li>沿海渔民</li></ol><p>大多数人不知道捕捞渔船价格多少，至少我知道的，普通型从不同功能配置及大小，价格区间在50w-200w，而且渔民多数都是贷款买的。开渔季，内需消费不动，捕捞又管，渔民贷款怎么办？</p><p>🧑‍🌾所以，左右互搏不是真的，因为真这么玩，玩死的是自己，而且这还是渔业。</p><p>你想想看，鼓动&#x2F;鼓吹 的人都是什么心思？一为流量，二为傻逼，三为坏透了。</p><p>而那些校园里老师这么说的是不是？媒体人是不是？</p><p>所以，有公众科学吗？一个专业老师，一个专业媒体都这样，更不要提老百姓。是不是这个逻辑？</p><p>话题切回来，这就是典型的思维问题、认知问题，没有这两个，哪里来的能力？谈何能力？谈何专业？</p><p>那为什么有的人思维可以？认知可以？甚至认知会突飞猛进？</p><p>这就是今天主要讲的事儿！</p><p>认知是属于思维层面里最重要的投资，ROI是最高的。如果你的认知层面突飞猛进，能够解决很多结构性问题。</p><ol><li>遇到巨大的挑战&#x2F;错误&#x2F;失败</li></ol><p>要想有认知的提升，就必须有困难的问题做牵引，甚至需要有一个非常可靠的「提问系统」。而如果身处一个快速发展的行业、持续增长的公司，就会天然面对挑战。</p><p>当业务量成倍增长的时候，人均产出一般是下降的。但是若希望业务高质量地增长，人均产出继续保持增长，则需要大幅提升效率。最常见的问题是如何用20%的人员增幅支持翻倍的业务目标？这种提升，需要从组织到个人做彻底的改变。对于组织而言，是组织升维；对于个人而言，是摆脱惯性，克服路径依赖，大幅提升甚至颠覆自己既往的认知。</p><p>所以，快速增长的公司本身，会成为非常有效的「提问系统」。这也是我为何建议大家在找工作时第一选择是看公司的成长性，适中有些创业公司符合，有些是不符合的，成长从长期看决定一切。</p><ol start="2"><li>有具体的、结构性的问题需要解决</li></ol><p>不论是生活、职场、人际关系等等都遭遇了非常具体的问题。这些问题如不解决，结果就是寸步难行 —— 因为单纯的努力不再有效，这意味着遭遇了「结构性」的问题，需要有颠覆性的解决方案。</p><p>又到了举例环节：比如原有的业务流程可能不再适用，需要重新梳理。而业务流程一旦发生变化，对应的组织架构必须调整，以匹配最新的业务流程。而流程和组织架构调整完之后，IT系统也必须随之调整。业务流程、组织架构、IT系统三要素，每件事都需要重新思考，重新规划。每个要素的改善，都是非常困难的问题。</p><ol start="3"><li>有稳定的标杆学习对象</li></ol><p>每个人都应该有自己的标杆学习对象，不论在生活中、网络中，包括每家公司也是如此。因为标杆学习对象可以引导我们找到正确的方向、获得勇气、掌握方法，从而逐步走出黑暗。甚至可以这样说，如果没有值得学习、模仿、借鉴的标杆学习对象，我们的进步速度是极慢的，进步的节奏也并不稳定。比如美团就在非常认真地学习Amazon，将关键经验深度内化，其中就包含「六页纸工作法」。</p><ol start="4"><li>能看到各部门的最佳实践</li></ol><p>因为部门定位的原因，我们天然活动于各部门之间，所以同时能看到各个部门的最佳实践：有些是关于方法论实践方面的，有些是关于部门流程梳理方面的，有些是关于组织架构方面的。因为很多人、很多部门的问题都是类似的，所以通过提炼、推广最佳实践，就能解决一类有共性的问题，而我们自身的认知，也在推广最佳实践的过程中得以提升。</p><p>看见一个现象、一个解法，可能觉得是偶然，但是看到两三个相似的现象，用同样的方法解决，就可以带来很好的启发。这个解法沉淀下来，就变成了自己的认知。</p><ol start="5"><li>有不少牛人能不断探讨、碰撞</li></ol><p>之前看讲述Google工作氛围的《重新定义公司》一书提到过一个观点：如果团队的人普遍比较出色，这样的团队氛围能吸引更多的人才加入。我最近对这个观点体会越来越深。</p><p>职场上找不到，那就现实生活中找。现实生活没有，那就在网络中找。总会有一个渠道是可以找到。如果你实在找不到，你真的应该考虑下：为什么自己这么失败，连个榜样都找不到。应该好好考虑下目前的 圈子&#x2F;圈层 ，是否还待下去。</p><ol start="6"><li>个人花更多时间「修路」，而非「开车」</li></ol><p>其实作为公司从0到1阶段成长起来的 管理者&#x2F;经营者 ，一般带兵打仗能力都很强，求战意识强，打仗手感也不错。但这同时也是一个问题，即碰到任何实际问题，这些管理者（包括我在内），一般都喜欢亲自上阵。这样看起来能更快地解决问题，其实有很大的隐患。</p><p>一方面，我们自己的行为方式都已经形成了惯性，在思维方式方面很难一下子能有颠覆性的成长；另一方面，当我们自己习惯于直接解决问题，其实让年轻人失去了锻炼成长的机会。在这种情况下，这些管理者更好的选择是多花时间修路，让部门里的年轻人多开车。即自己多花时间沉淀经验、搭建机制、提供支持，让年轻人站在第一线，去遭遇困难，解决难题。这对于自己、对于团队里的年轻人都是好事。</p><p>我自己惯用日历，老关注的同志都知道。本质是，我正在努力把更多的时间投向「修路」行为。</p><p>因为有了一定的「余闲」、有了「带宽」，反倒有精力做更深入的思考。这种选择客观上为自己的认知突破提供了「精力资源」—— 精力是一个人最宝贵的资源，要站在每天的维度，审慎分配。</p><p>🧑‍🌾以上，就是我对自己认知突进的一些解析，希望对各位同志有启发 —— 一旦你体会到因为认知突破而解决难题的快感，就会迷上这种感觉。</p>]]></content>
    
    
    <categories>
      
      <category>Life Co., Ltd.</category>
      
    </categories>
    
    
    <tags>
      
      <tag>life</tag>
      
      <tag>think</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>综合阅读三篇</title>
    <link href="/2025/02/28/%E7%BB%BC%E5%90%88%E9%98%85%E8%AF%BB%E4%B8%89%E7%AF%87/"/>
    <url>/2025/02/28/%E7%BB%BC%E5%90%88%E9%98%85%E8%AF%BB%E4%B8%89%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h3 id="session-1"><a href="#session-1" class="headerlink" title="session 1"></a>session 1</h3><p>近期我写了很多“主观性”「读写说」的方式方法，只是个人的一些小技巧罢了，难登大堂。</p><p>对于“利用率”来讲，在个人「职业&#x2F;生活 能力图谱」中的占比，真的很小，也就有20%吧</p><p>但是你不能忽略这20%的基础能力，因为它属于你的地基。而地基不好、基础不好，不论你去寻找「新知」还是巩固「旧知」都不会有太多的 成果&#x2F;结果 。</p><p>具象一点说</p><p>“写”的结果是文档，是“阐述”工具；而PPT 属于“说服”工具</p><p>如果你“写”的文档具有结构性&#x2F;架构性&#x2F;逻辑性，也就等于你的PPT制作能力也非常强，这也是“写”的结果。</p><p>那为什么PTT是“说服”工具？</p><p>因为你“写”的出来，那就能“说”的出来。</p><p>而“说”即是“说服”，不论你在什么行业什么岗位，我相信同志们都在不停的做 文档&#x2F;PPT，那你做完的结果呢？最终的结果到底是什么呢？</p><p>写出了具有「结构性&#x2F;架构性&#x2F;逻辑性」的“文档”是结果？</p><p>写出了具有「结构性&#x2F;架构性&#x2F;逻辑性」的“PPT”是结果？</p><p>的确可以“算”结果，因为他们只是阶段性、流程中的一个“小果”。只有这些在流程内的阶段性“小果”才能得到最终的“成果”&#x2F;“成功”</p><p>拿着你的“写”去说服你的同事&#x2F;上级&#x2F;老板，干死他们！得到了你的「利益」、完成了你想做的「事项」！</p><p>这TM才叫结果啊。</p><p>所以你们看，这明显也是个逻辑闭环且相互关联。</p><p>读 -&gt; 写-&gt; 说，是三个步骤，也是一个流程，更是你「职业能力图谱」中最最重要的基础。没有它们，你是无法做到更多的。</p><p>很多人会看到什么 职场&#x2F;人生 曲线，怎么说呢？曲尼玛！你啥都没，基础都不好，能TM曲？</p><p>所以，当你地基不稳的时候，应该立刻、马上去修补它、完善它。通过长期的努力和坚持，不仅有了很多“小果”还会有更多的“结果”。</p><h3 id="session-2"><a href="#session-2" class="headerlink" title="session 2"></a>session 2</h3><p>再讲一个「闭环流程」，属于个人「职业&#x2F;生活 能力图谱」中，占比70%的份额。那就是：信息&#x2F;认知 -&gt; 习惯&#x2F;专注 -&gt; 欲望&#x2F;目标&#x2F;结果</p><p>这个话题很大，要拆出来讲能废话很多，因为很多人从 科学角度、学术角度、纯理论没实战角度等等说过了很多。</p><p>所以，我也是从个人的“主观角度”来废一些。本文需要阅读30分钟，演讲需要40分钟，制作成PPT则至少需要20P</p><p>一、信息&#x2F;认知 </p><p>发现没？通过网络摄取的信息越多，你的记忆力和注意力反而显著下降，导致大脑出现「认知负荷」甚至出现「盲维」。而一个人每天接受的信息容量是有限的，我们需要把空间留给更有用更重要的事情。那么，如何使用「认知资源」呢？</p><ol><li>大脑又可笑既无聊</li></ol><p>很多人不论是带薪拉屎还是随机上厕所会带着手机，并非玩游戏，而是看视频、看新闻；在没有智能机的时代里，厕所都会放一些报纸和杂志，这被称为“厕所读物”。</p><p>也许，2000年后出生的孩子，对它印象不深，像我这个年纪，之前的人（80后）对厕所读物确有非常深刻的印象，家庭在厕所里放一些，不仅家人可以读，客人也会读。连公共厕所都会有，更何况公司呢？</p><p>我也理解并意识到一个“问题”，大脑容易无聊，无时无刻都要靠视觉、听觉来输入信息，一旦缺乏信息，就像食物的小动物一样，四处寻找可以获取信息的东西，听起来不可笑？</p><p>可是，长期「投喂内容」并非一件好事。使用电子产品过长，会使大脑灰质密度下降，主要处理「信息效率」那部分；另外，长期使用“社交媒体”，会减少海马体活动，记忆力和注意力下降，导致大脑出现进入认知负荷。</p><blockquote><p>所以为什么要养成精读精选，而不是用一些RSS工具订阅TM几百个，你看的过来？读的过来？你所谓的“读”最后理解了吗？最后还是不是不行？可笑又无聊</p></blockquote><p>在心理学中，目前缺乏，对认知负荷（Cognitive Workload）广泛认可且明确的定义。截止目前，它依然是一个「多维概念」。</p><p>诸多文献中，指作业人员「信息处理能力」和「认知资源」的比例，是否满足实际需要；以及，看做满足期望绩效所需，信息处理能力与可用处理能力之间的差异。而不同学者，也阐述出不同看法，比如：</p><p>Wickens是多重资源模型理论（Multiple Resource Theory，MRT）提出者；其认为工作量与任务、资源有一定关系，负荷反映着所执行任务时产生的心理压力。</p><p>Fernandez和Abbass等研究人员认为，工作环境与外部环境带来的认知负荷不同；前者会给后者带来“精神负荷”；一个人付出相当大脑力活动，信息处理效率会延迟，当信息处理超过所需容量，人的精神压力会接憧而至。</p><p>所以可以理解成：「认知负荷」涉及到日常工作中任务要求、时间压力、个人能力、以及绩效、努力程度，大脑处理问题效率等多个因素。</p><p>说人话则是：「认知」跟体力相似，如果过度使用它，会出现疲劳，当大脑表面工作超过整体运行占比时，脑力、心里等多方面不适的信号就会出现。</p><blockquote><p>举个运动场景的例子：没有接受过长期训练的人，在健身房一次连续举重次数越多，人越疲劳，直到失去平衡再也举不起来；认知同样，信息处理决策越多，人越乏力，最后大多决策不但非理性，还容易出现错误。</p></blockquote><p>用「 选择 (<a href="https://t.me/talkjfh/1234">https://t.me/talkjfh/1234</a>) 」来形容，最恰当不过。你可以把认知资源想象成一盆水池子，每天通过饮食、休息为它储备能量，进而，再把能量用在能够最大化创造价值的事情中。某种程度上，储备和消耗在一个池子中。假设，每天为一些“不重要”的事情，消耗大量资源，我们在思考或解决问题时，就会出现认知不足的情况；同样，如果白天做大量损耗资源的事，如果晚上需要做一些临时性决策，往往会，极为敷衍了事。</p><p>这些问题，总体可以分位生活&#x2F;工作 这两类中，比如：</p><p>【生活】<br>A. 很多人早晨起床第一眼就要看手机，刷牙时还要看短视频，任何情况下都要一心二用，坐地铁、打车路上边听歌、边刷朋友圈信息流，什么都记不住，还把脑袋搞的乱七八糟。</p><p>B. 很多女生要和闺蜜出去玩，常常因为化妆或穿衣打扮，白白浪费掉1-2个小时的时间，最后不但自己不满意，还会因迟到引发各种小事，造成一天玩乐都没心情。</p><p>【工作】<br>A. 经常开会中“愣住了”，一分钟后又回到正轨；打破砂锅问到底“刚才怎么了”？</p><p>B. 电脑&#x2F;手机上笔记的工具不下6-7个，他常常因为用哪个软件而纠结；现在各种效率软件如云，在海量选择中翱翔，也常把时间花在这些无效的事情上。</p><p>以上是不是你呢？</p><p>还有很多，它们都比较消耗认知资源，令大脑进入负荷状态；不妨回想下，从早起醒来到晚上睡觉之前，都做过哪些事情，这些重要吗？</p><p>或者，是不是我们大脑忙于思考很多并不重要的事，而浪费掉大量认知资源；亦或，大脑总想着重要的事情，到节骨眼，又束手无策了？</p><p>它们都容易让一天效率低下，最终，3-5件事都没干成，反而「认知资源」却被消耗光了。</p><ol start="2"><li>多简单，我控制不就得了</li></ol><p>“这问题很简单，我控制不就好了”，但是，你真的了解控制吗？为什么很多人的控制，最终走向了放弃？</p><p>自我控制也叫认知及控制（cognitive control），是人的执行功能。指选择某个目标，控制思想和行动，以达到目标与心理一致，我们也称之为“目标导向行为”。</p><blockquote><p>在这里，我又不得不提我一直在阐述的，做任何事情要有「欲望」、「目的」、「目标」、追求「结果」</p></blockquote><p>过程中，我们会基于「自我价值」、「判断目标」做出一系列计划，这些计划基于经验，又要适应无法预见的变化，还要监督行动，并抑制偏离目标的习惯反应，以保持目标。</p><blockquote><p>再次举例运动：跑步这么多年，如果你认为我“迫于自律”，那就大错特错；早期时，这种行动完全来源一种“厌恶感”，我讨厌自己吃胖，才勇于迈出。中期时，前一天带来的酸痛感，几乎第二天绝对不想去。隔天忙碌完，还是会不自觉的去跑，这又是为什么？这种感觉已经从最初的“厌恶”，发展成心理上的坚持，内心想，我总不能刚开始就放弃。现象持续1-2个月到后期，我基本开始享受跑步的过程，那种大汗淋漓的感觉，不仅能把身上虚汗排出，晚上还可以带来深度睡眠且精神抖擞，让你更加「专注」和排除「压力」，而在运动过程中，还可以更好的「聚焦目标」和「深度思考」。<br>何乐不为？</p></blockquote><p>所以「自我控制」包括5个方面：</p><p>涉及心理导向的决策（选择目标）、工作记忆（记住目标）、目标规划（分解目标），自上而下注意（专注目标相关的事情），以及元认知（监控自己的行为是否朝着目标走），因此它并非仅靠单一「意志力」心理活动。</p><p>那想象下自己是如何「控制」的呢？</p><p>A. 心中会暗暗发誓：“哎呀，不行了，我真的要减肥，从明天开始坚决不吃碳水化合物”，我要去煅炼！我要节食！</p><p>B. 想做一件事，从明天开始使劲的AII-IN，就像写文章，日更，坚持打卡，这些行为，两天后能量被耗尽。</p><p>以上是不是你呢？</p><p>「报复性松懈与控制」的模式，是大多数人问题的根源。</p><p>进一步说，大脑本身是矛盾体，每天要处理很多问题，这部分想这样，那部分想那样，我们表露在外面的只有一种情况，它们在心中必然会打架，会有一方胜出。</p><p>当大脑两部分、谁也无法说服谁时，自我会陷入“六神无主”境地中；一旦势均力敌、负面行为压倒正向想法，你会不会很纠结？损耗巨大精力不说，还会恨铁不成钢，认为“自己真没用，连这点小事情都管不住自己”。</p><p>诚然，「自我控制」跟游戏中角色的血量一样，短时间内有限，用力太猛，必定消耗太多，当控制资源短缺，对诱惑力下降，就会沉迷情绪中无法自拔。</p><p>可喜在于，「认知资源」属于再生资源，虽然会被消耗，但经过休息会恢复如初，有点像很多职场人，今天实在累的不堪，睡一觉，第二起来，依然元气满满。</p><p>所以，在此基础上，「认知资源」具备动态变化属性，一定范围内，你想自我控制，绝对能够做到；超过范围后，越控制越无法控制，反而进入内耗状态。有点像阀门，边界内，自我控制资源会越用越聪明，历经扩容后，逐渐走向正反馈，如果长期搁置不用，它也可能没有变化，甚至出现退化的可能。</p><ol start="3"><li>有限自制力</li></ol><p>失败的自我控制者对成事、动机、健康和幸福都会产生负面影响，成功的自我控制者，根本不会大脑进入“认知负荷”状态。‍这就产生出一个问题：</p><p>到底是自我控制却强，以后越容易控制，还是「越控制越容易放弃」？中间阈值到底该如何掌握？其实这个很容易，为什么呢？</p><p>心理学家Baumeister 等人对“有限自制力理论（The finite principle of self-control）”的研究，刚好解答这一切。</p><p> 什么是「有限自制力」呢？</p><p>简单讲，自制力是一种控制和约束自己情绪的能力，我们的自制力就像肌肉的力量，存在上限，当超过这个上限，即便大脑强迫出的各种想要做的行为，自己的控制行为都会下降。</p><blockquote><p>举例来说：你知道每天刷手机的行为已经让自己“疲惫不堪”，不想玩，要去控制，但过一段时间后，仍然会再次拿起手机。这种行为，心理学家认为就是「自我控制」的衰竭。它和疲劳存在共同特征，当身体疲劳或出现葡萄糖降低时，耐心就会下降。</p></blockquote><p>所以「动机」水平不同，导致随后的「结果」表现出现差异。</p><p>而不遵循 身体&#x2F;精神 的固有规律，一鼓作气想做成某事，必然走向“失败控制者”的队列；把事情做到能量耗竭之前，恢复后再进行，是“成功控制”者必备状态之一。</p><p>从另一个维度来看，关键只有一条：你不需要去做很多选择的事情，试着让一切变成「良好习惯」，才会降低自己认知资源的消耗、与控制力。</p><p>所以，只有超越意志力，你就能形成习惯。</p><p>二、习惯&#x2F;专注</p><p>「自我进化」是一把双刃剑，它给我们带来能力的同时也带来了痛苦。人们因能感知太多信息而感到心神不宁，或因产生过多欲望而痛苦不堪，又或因担忧能力不足而滋生焦虑。</p><h3 id="session-3"><a href="#session-3" class="headerlink" title="session 3"></a>session 3</h3><p>在能力上也如此。能力弱者极易分心，他们必须在一个理想的环境中才能学习，任何风吹草动都会让他们心神不宁；他们总是忍不住想做点更有趣的事情，一条热点新闻、一段有趣的闲聊都能把他们的注意力从重要的事情上移开。</p><blockquote><p>此处与【信息&#x2F;认知】有衔接，请自我思考</p></blockquote><p>能力强者则正好相反，他们的优势就在于能够主动屏蔽干扰，选择需要的信息并沉浸其中，为此他们甚至会主动练习。比如有人会故意在声音嘈杂的地方锻炼专注力，这使他拥有了随时随地进入深度阅读和思考状态的能力。</p><p>因「沉浸能力」的不同，最终处在了不同的层次。从大范围看，沉浸能力强的人时常处于支配层，沉浸能力弱的人时常处于被支配层。如果我们希望从人群中脱颖而出，就一定要刻意磨炼这种品质，或许这正是改变所谓“命运”的金钥匙。</p><ol><li>深度沉浸</li></ol><p>“主动选择信息”和“深度沉浸”是两个概念，但前者只是入口，后者才是关键。</p><p>因为能主动选择信息的人不一定能沉浸其中，所以很多人虽然能放下手机、拿起书本，能放弃娱乐、磨炼技能，甚至能大量练习，努力到感动自己，但他们就是无法让自己变得卓越。</p><p>这感觉就像是明明找到了双刃剑的安全剑柄，却不知道如何抓取，让人无比揪心。</p><p>这世上能“聚焦”的人很多，但“卓越”的人很少，其原因之一就是大多数人都缺乏「深度沉浸」的能力。</p><p>其实这么多废话就2点需要做，那就是：“正确的方法”+“大量的练习”</p><p>而所谓“正确”又不一样，参照谁呢？参考谁呢？学习谁呢？</p><p>我同样也不知道所谓“正确”是什么？但是能涉及到“正确<br>”无非有4个明显特征：</p><p>A. 有定义明确的目标</p><blockquote><p>目标定义越明确，注意力的感知精度就会越高，精力越集中，技能越精进</p></blockquote><p>B. 练习时极度专注</p><blockquote><p>谁都知道专注的重要性，但沉浸的关键是要做到“极度”专注，也就是说，在短时间内投入100%的精力，因为专注的真正动力并不是毅力和耐心，而是不断发现技巧上的微妙差异和持续存在的关注点，精力越集中则感知越细微。极度专注不仅是学习的关键，也是灵感的来源。</p></blockquote><p>C. 获得有效的反馈</p><blockquote><p>一般而言，不论做什么事情我们都需要反馈来准确识别自己在哪些方面还存在不足，以及为什么会存在不足。缺少反馈，我们既容易出错，又容易走神，而且很难快速提升个人能力。所以，想方设法得到及时、有效的指导和反馈是不断精进的重要条件。</p></blockquote><p>D. 拉伸区练习</p><blockquote><p>一味重复已经掌握的事情是没有意义的，但挑战太难的任务也会让自己感到挫败，二者都无法使人进入沉浸状态，好的状态应该介于二者之间。因为我们面对的不仅仅是兴趣，还有让人心生畏惧的「核心困难」。也就是说，我们每天都要做那些让自己感到有些困难但又可以通过努力来完成的事情，即跳出舒适区，避开困难区，处在拉伸区。</p></blockquote><p>所以，你需要「时刻审视自己」！</p><p>A.审视自己的注意力——是被动吸引还是主动选择？</p><p>B. 审视自己的沉浸度——是分心走神还是极度专注？</p><p>C. 审视自己的练习量——是浅尝辄止还是大量投入？</p><ol start="2"><li>专注力和注意力</li></ol><p>「专注力」对我们意味着什么？以及在日常生活中我们可以如何运用专注力？专注力的定义到底是什么？</p><p>首先一定要和「注意力」进行区分，「专注力」就像将一束光聚焦在某物上，始终是一个点。而「注意力」则可以宽广得多。</p><blockquote><p>比如，如果你有清晰的视野，我看不清楚那个人。但如果大厅光线充足，你不必专注就能看到坐在这里的所有人，而你只需要「注意力」；如果需要保持专注，你会看到这里所有人本来的样子。但是现在，你只对这一个人感兴趣，那么，你就需要「专注力」</p></blockquote><p>所以，我们之所以专注在某事，只是因为我们的注意力强度不够。如果我们的注意力非常强，就不需要专注在任何事情上。</p><p>谁好谁坏？其实并没有这么一说。</p><p>从「短期目的」来看，「专注力」的确非常有效，能让我们快速聚焦“一件事”并达成结果。譬如我现在正在写这篇文章，我非常的「专注」，以至于我知道目前这篇文章从结构来说，已经完成四分之三了，而剩下的就是一气呵成。</p><p>从「长期主义」来看，注意力的增强最终将使你变得有意识。让你把握了一切事物本来的样子。最重要的是你的头脑不会像棱镜那样运作，扭曲事物并创造出不存在的东西。你的头脑变得像一面镜子一样，只是映照出所有事物本来的样子。只有当你看到所有事物本来的样子时，你才拥有明智地处理一切的能力。否则，你会把很多事情弄得一团糟。这个阶段也就是中国禅宗大师青原行思提出参禅的三重境界：禅有悟时，看山不是山，看水不是水；禅中彻悟，看山仍然山，看水仍然是水。</p><p>而说人话也就是我们经常说的，人生三层阶段&#x2F;境界：看山是山，看山不是山，看山还是山</p><p>所以，「短期目的」的专注，可能性是有限的。但是它不可缺，你必须要踏实的一步步去完成，慢慢结出很多的“小果”（小结果），才能达成最终的「目的」（大结果）</p><p>而「长期主义」的专注则达成了「增强注意力」，则让你更加有「意识」，让你得以探索自身最高的可能性，以解决生活&#x2F;工作 中的关键问题。</p><blockquote><p>注：我清楚可能很多人不太理解这一段，但是我希望各位同志复制下来，慢慢的去体味&#x2F;体悟，先学会「短期目的」的专注为主。</p></blockquote><p>三、欲望&#x2F;目标&#x2F;结果</p><p>目标很重要，由此提炼出一个人成功的三大底层要素，分别是：目标力、思维模式和理性</p><p>如果我们能站在一生的终点回顾此生，会发现虽然此生是一条线，但是这条线上有若干关键节点，每个节点我们都称之为分水岭&#x2F;锚点，我们在每个分水岭&#x2F;锚点处所做的选择，最终决定我们人生的走势。</p><p>所以，人生由选择决定，而选择大于努力。</p><p>因为我们无法用“马后炮”的方式去分析选择，所以选择无所谓正确或者错误，选择只有质量高下之差别。那么什么决定了选择的质量？我认为本质就是「目标」</p><p>确切来说「选择的质量」决定于你自己的目标和被选择者的目标。被选择者可能是个人，也可能是一家组织，甚至可能是一个物体（如果你相信《禅与摩托车维修艺术》一书的核心概念「良质」的话）</p><p>一个好选择意味着目标的匹配，一个正确的选择意味着两个伟大目标的匹配。你有远大目标而所在企业没有，或者你只想找一份工作，而所在企业有远大目标，这都是不匹配的地方。个人与企业目标的不匹配会导致一段没有未来的联姻。</p><p>说完目标对选择质量的影响，再来探讨一下目标和成就的关系。设想一个「成就天平」，天平的一端是目标，另一端是能力。你需要问自己一个问题：你认为自己一生的成就，由哪个因素决定得更多一些，是目标还是能力？。</p><p>普通人相信“能力决定成就”，所以他的成就被限制在距离自己现有能力不远的地方。</p><p>而 牛人</p><blockquote><p>这里其实就是我一直说的「长期主义」和「复利」！因为你要有“成长”的台阶。</p><p>而这个“台阶”本质上是一种「指数效应」，每一阶段的积累对下一阶段的成长起到帮助。</p><p>长期看，富人越来越富是不争的事实，这对普通人的启发是什么？既然「富人越来越富，牛人越来越牛」的趋势不可改变，那我们唯一能做的事情不是去追他们，因为很难追上，而是切换个人成长的轨道，彻底改变自己固有的思维模式。</p><p>最重要的是也让自己进入同样的财富增长模式，尽早摆脱「求生」（谋生）这种hard 模式。<br><span style="color: #ff0000">多数人的焦虑也是在“此处”，说白了，“钱”不是万能的。但是不论在 现实社会&#x2F;虚拟社会（游戏） 中，「钱」比什么都重要。如果真的不重要，你在矫情什么？焦虑什么呢</span>？</p><p>作为普通人，投资「认知」最划算，但胡乱学习没有用。先换轨道（成长模式）再学习，这才是正途。</p><p>其实白手起家的普通人（多数人）之所以能改变命运，大多与创业和投资相关，而投资和创业本身就息息相关。作为普通人，如果无法深刻理解创业、商业和投资，将无法彻底改变自己的「命运」。</p><p>在理解这一点的基础上，我们应该为了培养自己对投资（A股TM算了吧）、商业和创业的「认知」，付出一切努力。</p></blockquote><p>相信成就是「目标」决定的，所以会根据目标去弥补能力。其实成就是目标和能力综合因素决定的，但是选择时更倾向于哪个，会带来完全不同的结果。</p><ol><li>设定目标</li></ol><p>目标设定的逻辑是根据必要性，而欲望则是前提。</p><p>一个是能力和路径依赖，人们习惯于根据自己现有的能力、资源去设立目标。这会大大局限你的发展。另一个是仅仅表达了欲望，但是没有充分挖掘必要性。后者目标设定出来，你自己也不信，更别提你的团队。一个你自己不信，团队不信的目标，只能用于做梦，安慰自己。</p><p>A. 牛人的目标是如何设定的？</p><p>从「长期主义」来看，千万不要盯着自己现有的能力去设定目标，这会大大局限你的想象力和发展空间。如果时间拉得足够长，目标与你现在有什么关系不大，与你能在多大程度上相信这个目标，也就是相信这个目标的必要性有关。</p><p>设定目标时，一定要能看到未来世界的发展。一旦看到了清晰的未来世界，那么设定远大目标就变成非常必要的事情。基于远大而必要的目标，反推自己需要怎样的能力，需要怎样的资源。</p><p>所以，牛人始终是牛人，大佬始终是大佬。没的比，层次在这，格局在这，完全不一样。</p><p>B. 那，我们的「目标」如何设定？</p><p>先看下错误的「欲望」，譬如：<br>问：你想买一幢什么样的房子？<br>答：我想买个别墅<br>问：为什么要买个别墅？<br>答：就是觉得好，不知道为什么。</p><blockquote><p>这就是典型的错误欲望，但没有必要性的挖掘，这样的目标，不具备任何牵引性。</p></blockquote><p>一旦能从「必要性」去分析，而不是基于现有「能力」或者「错误欲望」出发去分析，那么这个目标就会非常坚实，具备「相信」的基础。而目标具备可信力，是达成目标的重要基础。</p><p>正确的「欲望」，譬如：<br>问：你想买一个什么样的包？<br>答：我就是想买个包<br>问：为什么要买这个包？<br>答：因为以我目前的经济基础，在保证基础生活&#x2F;娱乐前提的情况下，三个月内我就可以买得起。而且我不需要省吃俭用、节衣缩食，而且这个包有助于提升我在商务场合上的身份。</p><blockquote><p>这就是基于现有「能力」和「目的」去设置的目标。</p></blockquote><p>总结一下，「目标设定」和「达成」是一个动态的、永续的过程，不断培养自己向外、向内感知的能力。</p><p>不断根据最新的认知，调整自己的目标（还是只考虑必要性，而不是能力），不断结构化地向内感知，知道自己的现状，知道自己在哪里，知道自己的能力和资源距离目标的要求还差多远，差在哪里。能不断找到有效策略去减小二者之间的差距。</p><p>最好的状态就是你在不断实现目标，而你又不断看到更大的世界，不断设立新的目标。按照这样的节奏，你会进入一个持续成长的迭代循环，既是「长期主义」。</p><p>但，是否能成为一个“牛人”还是需要很多功夫要做。实现你的自我闭环，具有成长性很重要。</p><p>所谓“工具”从来都不重要。重要的是：信息&#x2F;认知 -&gt; 习惯&#x2F;专注 -&gt; 欲望&#x2F;目标&#x2F;结果。</p><p>PS. 本文估计不到8k字，均在Mac.Telegram原生客户端上输出。此文也是本频道自开设以来，还算有点「深度」的内容了。希望各位同志能「利用」好，🙏🏻感谢观看。</p><h3 id="session-4"><a href="#session-4" class="headerlink" title="session 4"></a>session 4</h3><p>在「职业&#x2F;生活 能力图谱」中</p><p>“读写说”只能达到占比20%</p><p>而“人生决策论”达到70%</p><p>最后的10%，则是“天时地利人和”也就是所谓的「运气」</p><p>所以永远不会存在“完美”的人生，更没有“完美”的人。</p><p>阶级之分，全靠我们自身的「决策能力」。不论润还是不润，不是评判一个人“成功”的标准。</p><p>有能力，在哪里都「强」</p><p>没有能力，在哪里都「废」</p><p>而在我国传统教育所倡导的「读书&#x2F;知识 改变命运」是TM最扯淡和最傻逼的事儿</p>]]></content>
    
    
    <categories>
      
      <category>Life Co., Ltd.</category>
      
    </categories>
    
    
    <tags>
      
      <tag>life</tag>
      
      <tag>think</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学会「系统思考」、「创造性思维」和自主「期待效应」</title>
    <link href="/2025/02/28/%E5%AD%A6%E4%BC%9A%E3%80%8C%E7%B3%BB%E7%BB%9F%E6%80%9D%E8%80%83%E3%80%8D%E3%80%81%E3%80%8C%E5%88%9B%E9%80%A0%E6%80%A7%E6%80%9D%E7%BB%B4%E3%80%8D%E5%92%8C%E8%87%AA%E4%B8%BB%E3%80%8C%E6%9C%9F%E5%BE%85%E6%95%88%E5%BA%94%E3%80%8D/"/>
    <url>/2025/02/28/%E5%AD%A6%E4%BC%9A%E3%80%8C%E7%B3%BB%E7%BB%9F%E6%80%9D%E8%80%83%E3%80%8D%E3%80%81%E3%80%8C%E5%88%9B%E9%80%A0%E6%80%A7%E6%80%9D%E7%BB%B4%E3%80%8D%E5%92%8C%E8%87%AA%E4%B8%BB%E3%80%8C%E6%9C%9F%E5%BE%85%E6%95%88%E5%BA%94%E3%80%8D/</url>
    
    <content type="html"><![CDATA[<p>一、只有「系统思考」才能纵观全局</p><p>在生活、工作和学习中，我们总会面临一些复杂问题（很多问题本身十分复杂），我们可能会陷入思维僵化或思维空白的困境。这时，学会系统思考，从整体出发，学会看清事情背后的结构和逻辑，将成为解决问题的关键。</p><p>我们最终想要的：不管是工作上的难题，还是生活中的困境，当遇到问题时，能把事情想的清楚透彻并有效地解决是我们最想要的。思维有条理、思考有深度、有逻辑。</p><p>而现状是：在很多情况下，我们面临的不是思维僵化，而是思维空白，是面对难题时无从下手的窘境。这里会有以下3个主要原因：</p><p>很多问题的成因似乎很复杂，各种因素相互影响，难以理出头绪。</p><p>很多对策并未抓住问题的「本质」，只是“治标不治本”的“症状缓解”，或者不全面地解决问题，导致“按下葫芦浮起瓢”，到处救火、应接不暇。</p><p>很多「决策」反而产生了一连串的副作用，使局势更加恶化。</p><p>如何解决？</p><p>看着复杂，其实都源于其固有的简单：要素、关系（增强回路、调节回路、滞后效应）、功能&#x2F;目标</p><p>首先，「系统思考」需要先学会「视角转变」：</p><p>把你的视角从看局部拉升到看整体（看事情的全貌）</p><p>把你的视角从看要素转移到看关系（看内部的结构）</p><p>譬如，团队中，人就是要素，要素固然重要，但真正重要的是他们彼此之间的分工配合、是相处关系、是流程、制度、激励等（关系），看不见的关系比看得见的要素要重要的多。所以，许多组织运行效率慢，首先是系统的问题，而不是人的问题。</p><p>把你的视角从看静态变成看动态（看事物未来演化）<br>加入时间维度&#x2F;时间成本，让你看到事物背后的演化进程。</p><p>有的同志喜欢画图（脑图、系统图等），我并反对。初级在自身没有「系统思考」前，是可以利用此方式形成框架，有助于自己从全局角度去看一件事情，这个很好。</p><p>但是，你不能一直在用。</p><p>因为</p><p>「系统思考」是一种思维技能，不是一种画图技能。只做到“知道”的程度是远远不够的，动手练习才是知行合一的关键，而反复练习则是技能水平提升不可或缺的重要途径。</p><p>不断的反复练习，不断完善，借用&#x2F;利用工具，来锻炼我们的大脑，才是我们真正的「第二大脑」。</p><p>当你有了「系统思考」后想要走向认知提升，又面临“舒适区”的诱惑，那就需要「创造性思维」，实现新的人生里程。</p><p>有时候，为什么无法成功地解决问题？</p><p>这里就有个概念：最小阻力（line of least resistance）它是指，物体倾向于沿着阻力最小的路径移动，能量倾向于沿着最小阻力的路径传播。</p><p>如果我们只是不断改变目标，而不去改变环境，这并不是最小阻力的路径。</p><p>你可能会问，那我只需要改变环境不就好了吗？</p><p>实际上，我也曾尝试过这样做，但最后发现，自己又陷入了新环境的”舒适氛围”中。</p><p>经过认真的反思，我才意识到，我们通常认为的最小阻力，其实是一种“抄近道”。</p><p>譬如：很多刚毕业的学生，发现难以找到工作机会后，尝试通过报考各种MBA、EMBA商学院课程，来追求快速提升和掌握大量专业知识。他们很快发现这种速成并没有达到预期的结果。</p><p>毕竟，真正的一线实践工作与商学院的课堂教育是两回事。这种追求快速提升认知，而忽视实践经验的方法，最终导致能力的不足。</p><p>所以，最小阻力之路应该建立在“正确的正反馈”上。所以应该放下偏见，意识到问题并不在于“环境”，而是「整体结构」&#x2F;「系统结构」。</p><p>需要明确自己想要什么，并找到实现这些目标的有效方法，同时，也要认识到实现目标过程中，可能遇到的障碍；只有这样，才能解决在”相同问题”和”挑战之间”徘徊不定的困境。</p><p>创造本身，强调创新和突破性，创造性思维，要求我们跳出既有框架模式，以更开放，自由灵活的方式思考问题，它的关键在于”结构张力”。</p><p>这种张力，要能够摆脱（反抗-顺应）的循环，建立”相互吸引“的循环，以保证可以创造出所期待的结果。</p><p>那么以前运用「最小阻力思维」，为什么行不通？</p><p>一起 思考&#x2F;回想 下，你是不是有以下3点：</p><p>认不清&#x2F;看不到 现实<br>你想要取得的成就，和你现在的情况（能力）有很大差距。</p><p>但是，你又制定了一些计划，这些计划颗粒度太大。</p><p>就像“写一篇完整的文章、做一份项目报告”，包括理清逻辑、填充内容、收集数据，完成排版，准备案例，二次修改等细项。</p><p>这并不是一项可以一次完成的工作。如果按照传统方法，很容易产生当我看到一个任务时，我感觉任务好庞大，我到底做到哪了？一看无从下手，就有了放弃的心理。</p><p>这会造成认知负担。实际上，大脑逻辑比较简单，喜欢简单粗暴，不必不思考太多的事。这点就好像为什么短视频为什么会流行一样，短平快，不必不思考太多。</p><p>承受力变 弱&#x2F;差<br>喜欢按部就班地前进，不愿意犯错，不愿意拖延下一步的进展。</p><p>实际上，某些方面，总是与其他方面存在差异，这是无法避免的结果。</p><p>与理想目标之间的差距逐渐增大时，可能会感到沮丧，我们会质疑自己的自律性，认为，为什么如此缺乏自我控制能力？</p><p>大脑对”差距“产生的偏见，会默认为就是不好，进而引发消极情绪的可能性。</p><p>破罐子破摔 - 所谓躺平<br>当各种因素纠缠在一起时，我们就会失去动力，开始自我放纵之旅。堕落到一定程度后，可能会感到巨大的舒适和安慰，但渴望的力量也会重新变得更加强烈。</p><p>这就是，为什么大多数人在堕落和放弃一段时间后，会重新振作起来，开始努力进入下一个循环的原因。</p><p>这种循环可能会让我们陷入困境，重复相同的过程。</p><p>可以说，大多数人的“最小阻力”都发生在反向结构张力中。如同磁铁一样，并不是相互吸引，而是相互对峙。</p><p>所以，这种循环会不断重复、原地踏步，并且不停的在消耗自己。</p><p>所以要明白，「系统思考」和「创造性思维」，我们不应该过于强调环境有多糟糕或时间有多紧迫。</p><p>相反，系统创造于视角、动态和认知，创造性始于内心和思维，让我们所期望的美好结果不断浮现。</p><p>其次，需要明确自己想要实现的目标，然后实事求是地评估目前的能力水平，这个过程中，可能会发现自己目前的状态与理想目标之间存在很大的差距。</p><p>我们可以将这种差距，看作是一个激励努力追求目标的驱动力，它提醒着你仍有进步的空间，促使你充分利用自身的潜力。</p><p>通过接受差距并将其转化为动力，以保证，自己可以不断迈向更高的水平，这才是一种完整的正循环。</p><p>因此，与之前的做法不同，不再仅仅关注改变环境和一些细枝末节的小事，要开始专注于实现“我真正想要的大结果当中的每一个小结果”。</p><p>但是利用「创造性思维」做事会需要持续的能量，但当我们完成越来越多的指标性后，会遇到阻碍。</p><p>而这里最需要做的是：直面自己现状（面对现实）</p><p>对自己坦白，说出现状，避开评价；<br>想清楚你要干什么，明确目标，告诉自己，我要达成；<br>确定是否愿意做，是不是你想追求的方向；<br>踏实做事，不断前行。<br>当你对自己喜欢的事物产生期待，希望得到它的青睐，心理学家将这种行为称为“期待效应”。</p><p>在《影响力》一书中，作者丹尼尔·卡尼曼通过实验证明：人在表达“喜欢”时，会考虑对方的感受，不会只想到自己的利益。这一现象也被称为“皮格马利翁效应”。</p><p>所以我们可以利用“期待效应”，提高&#x2F;提升 自身。比如：</p><p>找到自己的优势，提升自己的价值。我们每个人都有自己独特的优势，比如有的人擅长交际，有的人擅长写作等等。当我们找到这些优势时，就能利用这一优势，让自己变得更有价值</p><p>向对方展示自己的能力。当我们想要获得对方的好感时，可以向对方展示自己的能力。比如你擅长写作，可以将自己写好的文章发给对方看；你擅长与人打交道，可以将你写好的文章发给对方看等等。</p><p>所以说，最省力的路，不一定是近路。</p><p>曾国藩曾经说过：别纠结过去的事，那已经无法改变。</p><p>而老子则教导我们：不要硬碰硬，像水一样，找出问题的解决办法。</p><p>人能跳，能跑，但也会累。累了就可能想要回头，想要放纵。</p><p>要走得远，就一步一个脚印，小步慢走。</p><p>《荀子·劝学》里曾警告我们：“驽马十驾，功在不舍”。一点一滴，才能累积成大成就。</p><p>也只有这样，才能让自己成为一个有价值、有认知、有能力的人。</p><p>因为只有这样，你才能在这个操蛋的社会里“<strong>活</strong>”的更好，不是吗？</p>]]></content>
    
    
    <categories>
      
      <category>Life Co., Ltd.</category>
      
    </categories>
    
    
    <tags>
      
      <tag>life</tag>
      
      <tag>think</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>人生有限公司</title>
    <link href="/2025/02/28/%E4%BA%BA%E7%94%9F%E6%9C%89%E9%99%90%E5%85%AC%E5%8F%B8/"/>
    <url>/2025/02/28/%E4%BA%BA%E7%94%9F%E6%9C%89%E9%99%90%E5%85%AC%E5%8F%B8/</url>
    
    <content type="html"><![CDATA[<p><strong>我们的「人生有限公司」是否能永久的持续下去，靠的唯有长期主义（「人生决策」系统 +「价值投资」系统）</strong></p><h3 id="什么是人生决策？"><a href="#什么是人生决策？" class="headerlink" title="什么是人生决策？"></a>什么是人生决策？</h3><p>“人生决策”可以理解为一种系统化的方法，用来指导我们在生命中的关键时刻做出选择。它类似于一个决策框架，可能包括以下几个要素：</p><ul><li>目标导向：明确你的人生目标，比如追求幸福、健康、财富、意义或影响力。</li><li>信息收集与分析：基于事实、经验和预测，评估每个选择的潜在结果。</li><li>优先级排序：根据你的核心价值观，决定哪些目标或结果更重要。</li><li>风险管理：权衡短期牺牲与长期收益，避免冲动或不可逆的错误。</li><li>反思与调整：定期回顾决策的效果，优化未来的选择。<br>比如，选择职业时，“人生决策”系统可能会让你问：这份工作是否符合我的长期兴趣？它能带来持续成长吗？它与我的价值观一致吗？这样的系统旨在让你的每一步都服务于更大的愿景，而不是被眼前的诱惑或压力牵着走。</li></ul><h3 id="什么是价值投资？"><a href="#什么是价值投资？" class="headerlink" title="什么是价值投资？"></a>什么是价值投资？</h3><p>“价值投资”原本是一个金融术语，由本杰明·格雷厄姆和沃伦·巴菲特等人推广，但在这里可以延伸到人生层面。它的核心理念是：以低于内在价值的价格买入优质资产，并长期持有，等待价值显现。</p><p>在人生语境中，“价值投资”可以指：</p><ul><li>识别“优质资产”：<ul><li>投资于那些长期有回报的事物，比如教育、健康、人际关系、技能或内在成长。</li></ul></li><li>低估时买入：<ul><li>抓住被忽视的机会，比如在别人看不到价值时坚持学习某项技能，或在市场低迷时创业。</li></ul></li><li>长期持有：<ul><li>耐心等待这些投资开花结果，而不是追求即时满足。比如，花时间建立深厚友谊，而不是只追求短期社交快感。</li></ul></li><li>避免投机：<ul><li>不被短期的流行趋势或浮躁的情绪驱动，而是基于理性和信念行事。</li></ul></li></ul><p>例如，把时间和精力投入到学习一门外语，可能短期看不到回报，但长期来看，它可能为你打开新的职业机会或文化视野，这就是一种“价值投资”。</p><h2 id="二者如何支撑“人生有限公司”的永久持续？"><a href="#二者如何支撑“人生有限公司”的永久持续？" class="headerlink" title="二者如何支撑“人生有限公司”的永久持续？"></a>二者如何支撑“人生有限公司”的永久持续？</h2><ul><li>人生决策系统提供了方向和纪律，确保你的每一步选择都指向长期目标。它像公司的战略规划，避免资源浪费。</li><li>价值投资系统则是执行工具，帮助你分配时间、精力、金钱等“资本”，投资于高回报的领域。它像公司的财务管理，确保资产增值。</li></ul><p>结合起来，这两个系统形成了一个闭环：决策系统帮你选对方向，价值投资系统帮你积累资源。长期主义则是<strong>贯穿始终</strong>的心态，要求你抵御诱惑、坚持耐心，最终让“<strong>人生有限公司</strong>”在时间中不断增值。</p><h2 id="现实中的可持续性"><a href="#现实中的可持续性" class="headerlink" title="现实中的可持续性"></a>现实中的可持续性</h2><p>不过，“永久持续”在现实中可能是个理想化的目标。人生有限，且充满不可控因素（健康、经济、社会变化等）。但通过长期主义，你可以最大化生命的质量和影响力，让“人生有限公司”在有限时间内实现最大的“股东价值”——这里的股东是你自己和你珍视的人。</p>]]></content>
    
    
    <categories>
      
      <category>Life Co., Ltd.</category>
      
    </categories>
    
    
    <tags>
      
      <tag>life</tag>
      
      <tag>think</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>knife4j 4.5.0 与 SpringBoot3.4.0-4 不兼容</title>
    <link href="/2025/02/28/knife4j-4-5-0-%E4%B8%8E-SpringBoot3-4-0-4-%E4%B8%8D%E5%85%BC%E5%AE%B9/"/>
    <url>/2025/02/28/knife4j-4-5-0-%E4%B8%8E-SpringBoot3-4-0-4-%E4%B8%8D%E5%85%BC%E5%AE%B9/</url>
    
    <content type="html"><![CDATA[<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"> #复现下场景:<br> <br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.github.xiaoymin<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span> com.github.xiaoymin<br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>knife4j-openapi3-jakarta-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span> knife4j-openapi3-jakarta-spring-boot-starter<br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.5.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span> 4.5.0 4.5.0 4.5.0<br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>  <br></code></pre></td></tr></table></figure><p>本来想从 SpringBoot 3.3.5 升级到最新的 3.4.4。但是升级后发现 Knife4j 文档地址doc.html进入后报错。</p><p><strong>java.lang.NoSuchMethodError: ‘void org.springframework.web.method.ControllerAdviceBean.<init>(java.lang.Object)’</strong></p><p>在全局异常解析中可以看到</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">at org.springdoc.core.service.GenericResponseService.lambda$getGenericMapResponse<span class="hljs-variable">$8</span>(GenericResponseService.java:702) ~[springdoc-openapi-starter-common-2.3.0.jar:2.3.0]<br>at java.base/java.util.stream.ReferencePipeline$2<span class="hljs-variable">$1</span>.accept(ReferencePipeline.java:178) ~[na:na]<br>at java.base/java.util.Spliterators<span class="hljs-variable">$ArraySpliterator</span>.forEachRemaining(Spliterators.java:992) ~[na:na]<br>at java.base/java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:509) ~[na:na]<br>at java.base/java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:499) ~[na:na]<br>at java.base/java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:575) ~[na:na]at org.springdoc.core.service.GenericResponseService.lambda$getGenericMapResponse<span class="hljs-variable">$8</span>(GenericResponseService.java:702) ~[springdoc-openapi-starter-common-2.3.0.jar:2.3.0]at java.base/java.util.stream.ReferencePipeline$2<span class="hljs-variable">$1</span>.accept(ReferencePipeline.java:178) ~[na:na]at java.base/java.util.Spliterators<span class="hljs-variable">$ArraySpliterator</span>.forEachRemaining(Spliterators.java:992) ~[na:na]at java.base/java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:509) ~[na:na]at java.base/java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:499) ~[na:na]at java.base/java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:575) ~[na:na]<br><br></code></pre></td></tr></table></figure><p>GenericResponseService  在 ‘springdoc-openapi-starter-common-2.3.0.jar’ 中<br>这里可以看到是 <code>org.springdoc.core.service.GenericResponseService</code>中的 <code>getGenericMapResponse</code> 方法。然后在这里找到何处调用了 <code>ControllerAdviceBean</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;String, ApiResponse&gt; genericApiResponseMap = (Map) controllerAdviceInfosInThisBean.stream().map(ControllerAdviceInfo::getApiResponseMap).collect(LinkedHashMap::<span class="hljs-keyword">new</span>, Map::putAll, Map::putAll);<br>        <span class="hljs-keyword">for</span> (ControllerAdviceInfo controllerAdviceInfo : <span class="hljs-built_in">this</span>.controllerAdviceInfos.stream().<br>                filter((controllerAdviceInfo) -&gt; (<span class="hljs-keyword">new</span><br>                        <span class="hljs-title class_">ControllerAdviceBean</span>(controllerAdviceInfo.getControllerAdvice())).<br>                        isApplicableToBeanType(beanType)).<br>                filter((controllerAdviceInfo) -&gt; !beanType.equals(controllerAdviceInfo.getControllerAdvice().<br>                        getClass())).<br>                toList()) &#123;<br>            controllerAdviceInfo.getApiResponseMap().forEach((key, apiResponse) -&gt; &#123;<br>                <span class="hljs-keyword">if</span> (!genericApiResponseMap.containsKey(key)) &#123;<br>                    genericApiResponseMap.put(key, apiResponse);<br>                &#125;<br>            &#125;);<br>        &#125;<br></code></pre></td></tr></table></figure><p>这里可以看到调用的 是一个参数</p><p>但是在 SpringBoot 3.4.0 ~4 中 spring-web-6.1.14.jar 的代码为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ControllerAdviceBean</span><span class="hljs-params">(String beanName, BeanFactory beanFactory, ControllerAdvice controllerAdvice)</span> &#123;<span class="hljs-keyword">public</span> <span class="hljs-title function_">ControllerAdviceBean</span><span class="hljs-params">(String beanName, BeanFactory beanFactory, ControllerAdvice controllerAdvice)</span> &#123;<br>    Assert.hasText(beanName, <span class="hljs-string">&quot;Bean name must contain text&quot;</span>);Assert.hasText(beanName,<span class="hljs-string">&quot;Bean name must contain text&quot;</span>);<br>    Assert.notNull(beanFactory, <span class="hljs-string">&quot;BeanFactory must not be null&quot;</span>);Assert.notNull(beanFactory,<span class="hljs-string">&quot;BeanFactory must not be null&quot;</span>);<br>    Assert.isTrue(beanFactory.containsBean(beanName), () -&gt; <span class="hljs-string">&quot;BeanFactory [&quot;</span> + beanFactory +<br>            <span class="hljs-string">&quot;] does not contain specified controller advice bean&#x27;&quot;</span> + beanName + <span class="hljs-string">&quot;&#x27;&quot;</span>);<span class="hljs-string">&quot;] does not contain specified controller advice bean&#x27;&quot;</span> + beanName + <span class="hljs-string">&quot;&#x27;&quot;</span>);<span class="hljs-string">&quot;] does not contain specified controller advice bean&#x27;&quot;</span> + beanName + <span class="hljs-string">&quot;&#x27;&quot;</span>);<br>    Assert.notNull(controllerAdvice, <span class="hljs-string">&quot;ControllerAdvice must not be null&quot;</span>);Assert.notNull(controllerAdvice, <span class="hljs-string">&quot;ControllerAdvice must not be null&quot;</span>);<br><br>    <span class="hljs-built_in">this</span>.beanName = beanName; <span class="hljs-built_in">this</span>.beanName = beanName;<br>    <span class="hljs-built_in">this</span>.isSingleton = beanFactory.isSingleton(beanName); <span class="hljs-built_in">this</span>.isSingleton = beanFactory.isSingleton(beanName);<br>    <span class="hljs-built_in">this</span>.beanType = getBeanType(beanName, beanFactory); <span class="hljs-built_in">this</span>.beanType = getBeanType(beanName, beanFactory);<br>    <span class="hljs-built_in">this</span>.beanTypePredicate = createBeanTypePredicate(controllerAdvice); <span class="hljs-built_in">this</span>.beanTypePredicate = createBeanTypePredicate(controllerAdvice);<br>    <span class="hljs-built_in">this</span>.beanFactory = beanFactory; <span class="hljs-built_in">this</span>.beanFactory = beanFactory;<br>&#125;<br></code></pre></td></tr></table></figure><p>属实是 knif4j 没有跟上节奏</p>]]></content>
    
    
    <categories>
      
      <category>develop</category>
      
    </categories>
    
    
    <tags>
      
      <tag>knife4j</tag>
      
      <tag>SpringBoot</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
